/*! For license information please see did-jwt.js.LICENSE.txt */
var t={456:t=>{t.exports=function t(e){if("number"==typeof e&&isNaN(e))throw new Error("NaN is not allowed");if("number"==typeof e&&!isFinite(e))throw new Error("Infinity is not allowed");return null===e||"object"!=typeof e?JSON.stringify(e):e.toJSON instanceof Function?t(e.toJSON()):Array.isArray(e)?`[${e.reduce(((e,r,n)=>`${e}${0===n?"":","}${t(void 0===r||"symbol"==typeof r?null:r)}`),"")}]`:`{${Object.keys(e).sort().reduce(((r,n)=>void 0===e[n]||"symbol"==typeof e[n]?r:`${r}${0===r.length?"":","}${t(n)}:${t(e[n])}`),"")}}`}}},e={};function r(n){var o=e[n];if(void 0!==o)return o.exports;var i=e[n]={exports:{}};return t[n](i,i.exports,r),i.exports}r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var n={};(()=>{r.d(n,{_D:()=>Mo,qT:()=>Qo,vo:()=>Xo,_J:()=>Zo,Fh:()=>hi,Qu:()=>Yo,R8:()=>Go,Ks:()=>Uo,K9:()=>Po,kr:()=>Qi,Gp:()=>Xi,Qf:()=>Fo,_6:()=>ss,ax:()=>os,P9:()=>is,aD:()=>ns,I7:()=>es,zO:()=>zi,pk:()=>Pi,XX:()=>Ii,qK:()=>Si,yv:()=>ts,xK:()=>Yi,fq:()=>Zi,xp:()=>Di,jB:()=>Vi,bK:()=>Ho,nr:()=>ko,AX:()=>rs,Mq:()=>qo,ZW:()=>_i,PZ:()=>Bi,Y:()=>ds,Qv:()=>fs,$1:()=>ps,_I:()=>hs,UR:()=>Gi,C2:()=>Mi});var t={};r.r(t),r.d(t,{base10:()=>$});var e={};r.r(e),r.d(e,{base16:()=>L,base16upper:()=>O});var o={};r.r(o),r.d(o,{base2:()=>R});var i={};r.r(i),r.d(i,{base256emoji:()=>D});var s={};r.r(s),r.d(s,{base32:()=>K,base32hex:()=>W,base32hexpad:()=>q,base32hexpadupper:()=>V,base32hexupper:()=>J,base32pad:()=>j,base32padupper:()=>H,base32upper:()=>_,base32z:()=>z});var a={};r.r(a),r.d(a,{base36:()=>F,base36upper:()=>M});var c={};r.r(c),r.d(c,{base58btc:()=>G,base58flickr:()=>Z});var f={};r.r(f),r.d(f,{base64:()=>X,base64pad:()=>Y,base64url:()=>Q,base64urlpad:()=>tt});var u={};r.r(u),r.d(u,{base8:()=>et});var h={};r.r(h),r.d(h,{identity:()=>rt});var d={};r.r(d),r.d(d,{code:()=>st,decode:()=>ct,encode:()=>at,name:()=>it});var l={};r.r(l),r.d(l,{code:()=>ut,decode:()=>dt,encode:()=>ht,name:()=>ft});var p={};r.r(p),r.d(p,{identity:()=>Ot});var y={};r.r(y),r.d(y,{sha256:()=>Ct,sha512:()=>Dt});var g={};function w(t){return null!=globalThis.Buffer?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t}function b(t=0){return null!=globalThis.Buffer?.allocUnsafe?w(globalThis.Buffer.allocUnsafe(t)):new Uint8Array(t)}function m(t,e){null==e&&(e=t.reduce(((t,e)=>t+e.length),0));const r=b(e);let n=0;for(const e of t)r.set(e,n),n+=e.length;return w(r)}r.r(g),r.d(g,{dQ:()=>Te,ci:()=>Se,bytesToNumberBE:()=>Ue,ty:()=>ke,eV:()=>Re,n$:()=>De,ql:()=>Oe,hexToBytes:()=>Pe,tL:()=>$e,S5:()=>Le,FF:()=>_e});const E=function(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<t.length;o++){var i=t.charAt(o),s=i.charCodeAt(0);if(255!==r[s])throw new TypeError(i+" is ambiguous");r[s]=o}var a=t.length,c=t.charAt(0),f=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function h(t){if("string"!=typeof t)throw new TypeError("Expected String");if(0===t.length)return new Uint8Array;var e=0;if(" "!==t[e]){for(var n=0,o=0;t[e]===c;)n++,e++;for(var i=(t.length-e)*f+1>>>0,s=new Uint8Array(i);t[e];){var u=r[t.charCodeAt(e)];if(255===u)return;for(var h=0,d=i-1;(0!==u||h<o)&&-1!==d;d--,h++)u+=a*s[d]>>>0,s[d]=u%256>>>0,u=u/256>>>0;if(0!==u)throw new Error("Non-zero carry");o=h,e++}if(" "!==t[e]){for(var l=i-o;l!==i&&0===s[l];)l++;for(var p=new Uint8Array(n+(i-l)),y=n;l!==i;)p[y++]=s[l++];return p}}}return{encode:function(e){if(e instanceof Uint8Array||(ArrayBuffer.isView(e)?e=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):Array.isArray(e)&&(e=Uint8Array.from(e))),!(e instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===e.length)return"";for(var r=0,n=0,o=0,i=e.length;o!==i&&0===e[o];)o++,r++;for(var s=(i-o)*u+1>>>0,f=new Uint8Array(s);o!==i;){for(var h=e[o],d=0,l=s-1;(0!==h||d<n)&&-1!==l;l--,d++)h+=256*f[l]>>>0,f[l]=h%a>>>0,h=h/a>>>0;if(0!==h)throw new Error("Non-zero carry");n=d,o++}for(var p=s-n;p!==s&&0===f[p];)p++;for(var y=c.repeat(r);p<s;++p)y+=t.charAt(f[p]);return y},decodeUnsafe:h,decode:function(t){var r=h(t);if(r)return r;throw new Error(`Non-${e} character`)}}},v=(new Uint8Array(0),t=>{if(t instanceof Uint8Array&&"Uint8Array"===t.constructor.name)return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")});class x{constructor(t,e,r){this.name=t,this.prefix=e,this.baseEncode=r}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}}class A{constructor(t,e,r){if(this.name=t,this.prefix=e,void 0===e.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=e.codePointAt(0),this.baseDecode=r}decode(t){if("string"==typeof t){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(t){return S(this,t)}}class B{constructor(t){this.decoders=t}or(t){return S(this,t)}decode(t){const e=t[0],r=this.decoders[e];if(r)return r.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const S=(t,e)=>new B({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}});class I{constructor(t,e,r,n){this.name=t,this.prefix=e,this.baseEncode=r,this.baseDecode=n,this.encoder=new x(t,e,r),this.decoder=new A(t,e,n)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}}const P=({name:t,prefix:e,encode:r,decode:n})=>new I(t,e,r,n),U=({prefix:t,name:e,alphabet:r})=>{const{encode:n,decode:o}=E(r,e);return P({prefix:t,name:e,encode:n,decode:t=>v(o(t))})},k=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>P({prefix:e,name:t,encode:t=>((t,e,r)=>{const n="="===e[e.length-1],o=(1<<r)-1;let i="",s=0,a=0;for(let n=0;n<t.length;++n)for(a=a<<8|t[n],s+=8;s>r;)s-=r,i+=e[o&a>>s];if(s&&(i+=e[o&a<<r-s]),n)for(;i.length*r&7;)i+="=";return i})(t,n,r),decode:e=>((t,e,r,n)=>{const o={};for(let t=0;t<e.length;++t)o[e[t]]=t;let i=t.length;for(;"="===t[i-1];)--i;const s=new Uint8Array(i*r/8|0);let a=0,c=0,f=0;for(let e=0;e<i;++e){const i=o[t[e]];if(void 0===i)throw new SyntaxError(`Non-${n} character`);c=c<<r|i,a+=r,a>=8&&(a-=8,s[f++]=255&c>>a)}if(a>=r||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return s})(e,n,r,t)}),$=U({prefix:"9",name:"base10",alphabet:"0123456789"}),L=k({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),O=k({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),R=k({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),T=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),N=T.reduce(((t,e,r)=>(t[r]=e,t)),[]),C=T.reduce(((t,e,r)=>(t[e.codePointAt(0)]=r,t)),[]),D=P({prefix:"🚀",name:"base256emoji",encode:function(t){return t.reduce(((t,e)=>t+N[e]),"")},decode:function(t){const e=[];for(const r of t){const t=C[r.codePointAt(0)];if(void 0===t)throw new Error(`Non-base256emoji character: ${r}`);e.push(t)}return new Uint8Array(e)}}),K=k({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),_=k({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),j=k({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),H=k({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),W=k({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),J=k({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),q=k({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),V=k({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),z=k({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),F=U({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),M=U({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),G=U({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Z=U({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),X=k({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Y=k({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Q=k({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),tt=k({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),et=k({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),rt=P({prefix:"\0",name:"identity",encode:t=>{return e=t,(new TextDecoder).decode(e);var e},decode:t=>(t=>(new TextEncoder).encode(t))(t)}),nt=new TextEncoder,ot=new TextDecoder,it="json",st=512,at=t=>nt.encode(JSON.stringify(t)),ct=t=>JSON.parse(ot.decode(t)),ft="raw",ut=85,ht=t=>v(t),dt=t=>v(t);var lt=128,pt=-128,yt=Math.pow(2,31),gt=Math.pow(2,7),wt=Math.pow(2,14),bt=Math.pow(2,21),mt=Math.pow(2,28),Et=Math.pow(2,35),vt=Math.pow(2,42),xt=Math.pow(2,49),At=Math.pow(2,56),Bt=Math.pow(2,63);const St=function t(e,r,n){r=r||[];for(var o=n=n||0;e>=yt;)r[n++]=255&e|lt,e/=128;for(;e&pt;)r[n++]=255&e|lt,e>>>=7;return r[n]=0|e,t.bytes=n-o+1,r},It=function(t){return t<gt?1:t<wt?2:t<bt?3:t<mt?4:t<Et?5:t<vt?6:t<xt?7:t<At?8:t<Bt?9:10},Pt=(t,e,r=0)=>(St(t,e,r),e),Ut=t=>It(t),kt=(t,e)=>{const r=e.byteLength,n=Ut(t),o=n+Ut(r),i=new Uint8Array(o+r);return Pt(t,i,0),Pt(r,i,n),i.set(e,o),new $t(t,r,e,i)};class $t{constructor(t,e,r,n){this.code=t,this.size=e,this.digest=r,this.bytes=n}}const Lt=v,Ot={code:0,name:"identity",encode:Lt,digest:t=>kt(0,Lt(t))},Rt=({name:t,code:e,encode:r})=>new Tt(t,e,r);class Tt{constructor(t,e,r){this.name=t,this.code=e,this.encode=r}digest(t){if(t instanceof Uint8Array){const e=this.encode(t);return e instanceof Uint8Array?kt(this.code,e):e.then((t=>kt(this.code,t)))}throw Error("Unknown type, must be binary type")}}const Nt=t=>async e=>new Uint8Array(await crypto.subtle.digest(t,e)),Ct=Rt({name:"sha2-256",code:18,encode:Nt("SHA-256")}),Dt=Rt({name:"sha2-512",code:19,encode:Nt("SHA-512")});new WeakMap,Symbol.toStringTag,Symbol.for("nodejs.util.inspect.custom"),Symbol.for("@ipld/js-cid/CID");const Kt={...h,...o,...u,...t,...e,...s,...a,...c,...f,...i};function _t(t,e,r,n){return{name:t,prefix:e,encoder:{name:t,prefix:e,encode:r},decoder:{decode:n}}}const jt=_t("utf8","u",(t=>"u"+new TextDecoder("utf8").decode(t)),(t=>(new TextEncoder).encode(t.substring(1)))),Ht=_t("ascii","a",(t=>{let e="a";for(let r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e}),(t=>{const e=b((t=t.substring(1)).length);for(let r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e})),Wt={utf8:jt,"utf-8":jt,hex:Kt.base16,latin1:Ht,ascii:Ht,binary:Ht,...Kt};function Jt(t,e="utf8"){const r=Wt[e];if(null==r)throw new Error(`Unsupported encoding "${e}"`);return"utf8"!==e&&"utf-8"!==e||null==globalThis.Buffer||null==globalThis.Buffer.from?r.decoder.decode(`${r.prefix}${t}`):w(globalThis.Buffer.from(t,"utf-8"))}function qt(t,e="utf8"){const r=Wt[e];if(null==r)throw new Error(`Unsupported encoding "${e}"`);return"utf8"!==e&&"utf-8"!==e||null==globalThis.Buffer||null==globalThis.Buffer.from?r.encoder.encode(t).substring(1):globalThis.Buffer.from(t.buffer,t.byteOffset,t.byteLength).toString("utf8")}function Vt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function zt(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function Ft(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function Mt(t,e){zt(t);const r=e.outputLen;if(t.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}const Gt="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0,Zt=t=>t instanceof Uint8Array,Xt=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),Yt=(t,e)=>t<<32-e|t>>>e;if(68!==new Uint8Array(new Uint32Array([287454020]).buffer)[0])throw new Error("Non little-endian hardware is not supported");function Qt(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}function te(t){if("string"==typeof t&&(t=Qt(t)),!Zt(t))throw new Error("expected Uint8Array, got "+typeof t);return t}function ee(...t){const e=new Uint8Array(t.reduce(((t,e)=>t+e.length),0));let r=0;return t.forEach((t=>{if(!Zt(t))throw new Error("Uint8Array expected");e.set(t,r),r+=t.length})),e}class re{clone(){return this._cloneInto()}}function ne(t){const e=e=>t().update(te(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}function oe(t=32){if(Gt&&"function"==typeof Gt.getRandomValues)return Gt.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}class ie extends re{constructor(t,e,r,n){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Xt(this.buffer)}update(t){Ft(this);const{view:e,buffer:r,blockLen:n}=this,o=(t=te(t)).length;for(let i=0;i<o;){const s=Math.min(n-this.pos,o-i);if(s!==n)r.set(t.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===n&&(this.process(e,0),this.pos=0);else{const e=Xt(t);for(;n<=o-i;i+=n)this.process(e,i)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){Ft(this),Mt(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:n,isLE:o}=this;let{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>n-i&&(this.process(r,0),i=0);for(let t=i;t<n;t++)e[t]=0;!function(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const o=BigInt(32),i=BigInt(4294967295),s=Number(r>>o&i),a=Number(r&i),c=n?4:0,f=n?0:4;t.setUint32(e+c,s,n),t.setUint32(e+f,a,n)}(r,n-8,BigInt(8*this.length),o),this.process(r,0);const s=Xt(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=a/4,f=this.get();if(c>f.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<c;t++)s.setUint32(4*t,f[t],o)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:o,destroyed:i,pos:s}=this;return t.length=n,t.pos=s,t.finished=o,t.destroyed=i,n%e&&t.buffer.set(r),t}}const se=BigInt(2**32-1),ae=BigInt(32);function ce(t,e=!1){return e?{h:Number(t&se),l:Number(t>>ae&se)}:{h:0|Number(t>>ae&se),l:0|Number(t&se)}}function fe(t,e=!1){let r=new Uint32Array(t.length),n=new Uint32Array(t.length);for(let o=0;o<t.length;o++){const{h:i,l:s}=ce(t[o],e);[r[o],n[o]]=[i,s]}return[r,n]}const ue=(t,e,r)=>t<<r|e>>>32-r,he=(t,e,r)=>e<<r|t>>>32-r,de=(t,e,r)=>e<<r-32|t>>>64-r,le=(t,e,r)=>t<<r-32|e>>>64-r,pe={fromBig:ce,split:fe,toBig:(t,e)=>BigInt(t>>>0)<<ae|BigInt(e>>>0),shrSH:(t,e,r)=>t>>>r,shrSL:(t,e,r)=>t<<32-r|e>>>r,rotrSH:(t,e,r)=>t>>>r|e<<32-r,rotrSL:(t,e,r)=>t<<32-r|e>>>r,rotrBH:(t,e,r)=>t<<64-r|e>>>r-32,rotrBL:(t,e,r)=>t>>>r-32|e<<64-r,rotr32H:(t,e)=>e,rotr32L:(t,e)=>t,rotlSH:ue,rotlSL:he,rotlBH:de,rotlBL:le,add:function(t,e,r,n){const o=(e>>>0)+(n>>>0);return{h:t+r+(o/2**32|0)|0,l:0|o}},add3L:(t,e,r)=>(t>>>0)+(e>>>0)+(r>>>0),add3H:(t,e,r,n)=>e+r+n+(t/2**32|0)|0,add4L:(t,e,r,n)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0),add4H:(t,e,r,n,o)=>e+r+n+o+(t/2**32|0)|0,add5H:(t,e,r,n,o,i)=>e+r+n+o+i+(t/2**32|0)|0,add5L:(t,e,r,n,o)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0)+(o>>>0)},[ye,ge]=(()=>pe.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((t=>BigInt(t)))))(),we=new Uint32Array(80),be=new Uint32Array(80);class me extends ie{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:e,Bh:r,Bl:n,Ch:o,Cl:i,Dh:s,Dl:a,Eh:c,El:f,Fh:u,Fl:h,Gh:d,Gl:l,Hh:p,Hl:y}=this;return[t,e,r,n,o,i,s,a,c,f,u,h,d,l,p,y]}set(t,e,r,n,o,i,s,a,c,f,u,h,d,l,p,y){this.Ah=0|t,this.Al=0|e,this.Bh=0|r,this.Bl=0|n,this.Ch=0|o,this.Cl=0|i,this.Dh=0|s,this.Dl=0|a,this.Eh=0|c,this.El=0|f,this.Fh=0|u,this.Fl=0|h,this.Gh=0|d,this.Gl=0|l,this.Hh=0|p,this.Hl=0|y}process(t,e){for(let r=0;r<16;r++,e+=4)we[r]=t.getUint32(e),be[r]=t.getUint32(e+=4);for(let t=16;t<80;t++){const e=0|we[t-15],r=0|be[t-15],n=pe.rotrSH(e,r,1)^pe.rotrSH(e,r,8)^pe.shrSH(e,r,7),o=pe.rotrSL(e,r,1)^pe.rotrSL(e,r,8)^pe.shrSL(e,r,7),i=0|we[t-2],s=0|be[t-2],a=pe.rotrSH(i,s,19)^pe.rotrBH(i,s,61)^pe.shrSH(i,s,6),c=pe.rotrSL(i,s,19)^pe.rotrBL(i,s,61)^pe.shrSL(i,s,6),f=pe.add4L(o,c,be[t-7],be[t-16]),u=pe.add4H(f,n,a,we[t-7],we[t-16]);we[t]=0|u,be[t]=0|f}let{Ah:r,Al:n,Bh:o,Bl:i,Ch:s,Cl:a,Dh:c,Dl:f,Eh:u,El:h,Fh:d,Fl:l,Gh:p,Gl:y,Hh:g,Hl:w}=this;for(let t=0;t<80;t++){const e=pe.rotrSH(u,h,14)^pe.rotrSH(u,h,18)^pe.rotrBH(u,h,41),b=pe.rotrSL(u,h,14)^pe.rotrSL(u,h,18)^pe.rotrBL(u,h,41),m=u&d^~u&p,E=h&l^~h&y,v=pe.add5L(w,b,E,ge[t],be[t]),x=pe.add5H(v,g,e,m,ye[t],we[t]),A=0|v,B=pe.rotrSH(r,n,28)^pe.rotrBH(r,n,34)^pe.rotrBH(r,n,39),S=pe.rotrSL(r,n,28)^pe.rotrBL(r,n,34)^pe.rotrBL(r,n,39),I=r&o^r&s^o&s,P=n&i^n&a^i&a;g=0|p,w=0|y,p=0|d,y=0|l,d=0|u,l=0|h,({h:u,l:h}=pe.add(0|c,0|f,0|x,0|A)),c=0|s,f=0|a,s=0|o,a=0|i,o=0|r,i=0|n;const U=pe.add3L(A,S,P);r=pe.add3H(U,x,B,I),n=0|U}({h:r,l:n}=pe.add(0|this.Ah,0|this.Al,0|r,0|n)),({h:o,l:i}=pe.add(0|this.Bh,0|this.Bl,0|o,0|i)),({h:s,l:a}=pe.add(0|this.Ch,0|this.Cl,0|s,0|a)),({h:c,l:f}=pe.add(0|this.Dh,0|this.Dl,0|c,0|f)),({h:u,l:h}=pe.add(0|this.Eh,0|this.El,0|u,0|h)),({h:d,l}=pe.add(0|this.Fh,0|this.Fl,0|d,0|l)),({h:p,l:y}=pe.add(0|this.Gh,0|this.Gl,0|p,0|y)),({h:g,l:w}=pe.add(0|this.Hh,0|this.Hl,0|g,0|w)),this.set(r,n,o,i,s,a,c,f,u,h,d,l,p,y,g,w)}roundClean(){we.fill(0),be.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Ee=ne((()=>new me)),ve=(BigInt(0),BigInt(1)),xe=BigInt(2),Ae=t=>t instanceof Uint8Array,Be=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function Se(t){if(!Ae(t))throw new Error("Uint8Array expected");let e="";for(let r=0;r<t.length;r++)e+=Be[t[r]];return e}function Ie(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}function Pe(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(e/2);for(let e=0;e<r.length;e++){const n=2*e,o=t.slice(n,n+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");r[e]=i}return r}function Ue(t){return Ie(Se(t))}function ke(t){if(!Ae(t))throw new Error("Uint8Array expected");return Ie(Se(Uint8Array.from(t).reverse()))}function $e(t,e){return Pe(t.toString(16).padStart(2*e,"0"))}function Le(t,e){return $e(t,e).reverse()}function Oe(t,e,r){let n;if("string"==typeof e)try{n=Pe(e)}catch(r){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${r}`)}else{if(!Ae(e))throw new Error(`${t} must be hex string or Uint8Array`);n=Uint8Array.from(e)}const o=n.length;if("number"==typeof r&&o!==r)throw new Error(`${t} expected ${r} bytes, got ${o}`);return n}function Re(...t){const e=new Uint8Array(t.reduce(((t,e)=>t+e.length),0));let r=0;return t.forEach((t=>{if(!Ae(t))throw new Error("Uint8Array expected");e.set(t,r),r+=t.length})),e}const Te=t=>(xe<<BigInt(t-1))-ve,Ne=t=>new Uint8Array(t),Ce=t=>Uint8Array.from(t);function De(t,e,r){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=Ne(t),o=Ne(t),i=0;const s=()=>{n.fill(1),o.fill(0),i=0},a=(...t)=>r(o,n,...t),c=(t=Ne())=>{o=a(Ce([0]),t),n=a(),0!==t.length&&(o=a(Ce([1]),t),n=a())},f=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const r=[];for(;t<e;){n=a();const e=n.slice();r.push(e),t+=n.length}return Re(...r)};return(t,e)=>{let r;for(s(),c(t);!(r=e(f()));)c();return s(),r}}const Ke={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function _e(t,e,r={}){const n=(e,r,n)=>{const o=Ke[r];if("function"!=typeof o)throw new Error(`Invalid validator "${r}", expected function`);const i=t[e];if(!(n&&void 0===i||o(i,t)))throw new Error(`Invalid param ${String(e)}=${i} (${typeof i}), expected ${r}`)};for(const[t,r]of Object.entries(e))n(t,r,!1);for(const[t,e]of Object.entries(r))n(t,e,!0);return t}const je=BigInt(0),He=BigInt(1),We=BigInt(2),Je=BigInt(3),qe=BigInt(4),Ve=BigInt(5),ze=BigInt(8);function Fe(t,e){const r=t%e;return r>=je?r:e+r}function Me(t,e,r){if(r<=je||e<je)throw new Error("Expected power/modulo > 0");if(r===He)return je;let n=He;for(;e>je;)e&He&&(n=n*t%r),t=t*t%r,e>>=He;return n}function Ge(t,e,r){let n=t;for(;e-- >je;)n*=n,n%=r;return n}function Ze(t,e){if(t===je||e<=je)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=Fe(t,e),n=e,o=je,i=He,s=He,a=je;for(;r!==je;){const t=n/r,e=n%r,c=o-s*t,f=i-a*t;n=r,r=e,o=s,i=a,s=c,a=f}if(n!==He)throw new Error("invert: does not exist");return Fe(o,e)}BigInt(9),BigInt(16);const Xe=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ye(t,e){const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Qe(t,e,r=!1,n={}){if(t<=je)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:i}=Ye(t,e);if(i>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=function(t){if(t%qe===Je){const e=(t+He)/qe;return function(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root");return n}}if(t%ze===Ve){const e=(t-Ve)/ze;return function(t,r){const n=t.mul(r,We),o=t.pow(n,e),i=t.mul(r,o),s=t.mul(t.mul(i,We),o),a=t.mul(i,t.sub(s,t.ONE));if(!t.eql(t.sqr(a),r))throw new Error("Cannot find square root");return a}}return function(t){const e=(t-He)/We;let r,n,o;for(r=t-He,n=0;r%We===je;r/=We,n++);for(o=We;o<t&&Me(o,e,t)!==t-He;o++);if(1===n){const e=(t+He)/qe;return function(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root");return n}}const i=(r+He)/We;return function(t,s){if(t.pow(s,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let a=n,c=t.pow(t.mul(t.ONE,o),r),f=t.pow(s,i),u=t.pow(s,r);for(;!t.eql(u,t.ONE);){if(t.eql(u,t.ZERO))return t.ZERO;let e=1;for(let r=t.sqr(u);e<a&&!t.eql(r,t.ONE);e++)r=t.sqr(r);const r=t.pow(c,He<<BigInt(a-e-1));c=t.sqr(r),f=t.mul(f,r),u=t.mul(u,c),a=e}return f}}(t)}(t),a=Object.freeze({ORDER:t,BITS:o,BYTES:i,MASK:Te(o),ZERO:je,ONE:He,create:e=>Fe(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("Invalid field element: expected bigint, got "+typeof e);return je<=e&&e<t},is0:t=>t===je,isOdd:t=>(t&He)===He,neg:e=>Fe(-e,t),eql:(t,e)=>t===e,sqr:e=>Fe(e*e,t),add:(e,r)=>Fe(e+r,t),sub:(e,r)=>Fe(e-r,t),mul:(e,r)=>Fe(e*r,t),pow:(t,e)=>function(t,e,r){if(r<je)throw new Error("Expected power > 0");if(r===je)return t.ONE;if(r===He)return e;let n=t.ONE,o=e;for(;r>je;)r&He&&(n=t.mul(n,o)),o=t.sqr(o),r>>=He;return n}(a,t,e),div:(e,r)=>Fe(e*Ze(r,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>Ze(e,t),sqrt:n.sqrt||(t=>s(a,t)),invertBatch:t=>function(t,e){const r=new Array(e.length),n=e.reduce(((e,n,o)=>t.is0(n)?e:(r[o]=e,t.mul(e,n))),t.ONE),o=t.inv(n);return e.reduceRight(((e,n,o)=>t.is0(n)?e:(r[o]=t.mul(e,r[o]),t.mul(e,n))),o),r}(a,t),cmov:(t,e,r)=>r?e:t,toBytes:t=>r?Le(t,i):$e(t,i),fromBytes:t=>{if(t.length!==i)throw new Error(`Fp.fromBytes: expected ${i}, got ${t.length}`);return r?ke(t):Ue(t)}});return Object.freeze(a)}function tr(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function er(t){const e=tr(t);return e+Math.ceil(e/2)}const rr=BigInt(0),nr=BigInt(1);function or(t,e){const r=(t,e)=>{const r=e.negate();return t?r:e},n=t=>({windows:Math.ceil(e/t)+1,windowSize:2**(t-1)});return{constTimeNegate:r,unsafeLadder(e,r){let n=t.ZERO,o=e;for(;r>rr;)r&nr&&(n=n.add(o)),o=o.double(),r>>=nr;return n},precomputeWindow(t,e){const{windows:r,windowSize:o}=n(e),i=[];let s=t,a=s;for(let t=0;t<r;t++){a=s,i.push(a);for(let t=1;t<o;t++)a=a.add(s),i.push(a);s=a.double()}return i},wNAF(e,o,i){const{windows:s,windowSize:a}=n(e);let c=t.ZERO,f=t.BASE;const u=BigInt(2**e-1),h=2**e,d=BigInt(e);for(let t=0;t<s;t++){const e=t*a;let n=Number(i&u);i>>=d,n>a&&(n-=h,i+=nr);const s=e,l=e+Math.abs(n)-1,p=t%2!=0,y=n<0;0===n?f=f.add(r(p,o[s])):c=c.add(r(y,o[l]))}return{p:c,f}},wNAFCached(t,e,r,n){const o=t._WINDOW_SIZE||1;let i=e.get(t);return i||(i=this.precomputeWindow(t,o),1!==o&&e.set(t,n(i))),this.wNAF(o,i,r)}}}function ir(t){return _e(t.Fp,Xe.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),_e(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ye(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}const sr=BigInt(0),ar=BigInt(1),cr=BigInt(2),fr=BigInt(8),ur={zip215:!0};function hr(t){const e=function(t){const e=ir(t);return _e(t,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}(t),{Fp:r,n,prehash:o,hash:i,randomBytes:s,nByteLength:a,h:c}=e,f=cr<<BigInt(8*a)-ar,u=r.create,h=e.uvRatio||((t,e)=>{try{return{isValid:!0,value:r.sqrt(t*r.inv(e))}}catch(t){return{isValid:!1,value:sr}}}),d=e.adjustScalarBytes||(t=>t),l=e.domain||((t,e,r)=>{if(e.length||r)throw new Error("Contexts/pre-hash are not supported");return t}),p=t=>"bigint"==typeof t&&sr<t,y=(t,e)=>p(t)&&p(e)&&t<e,g=t=>t===sr||y(t,f);function w(t,e){if(y(t,e))return t;throw new Error(`Expected valid scalar < ${e}, got ${typeof t} ${t}`)}function b(t){return t===sr?t:w(t,n)}const m=new Map;function E(t){if(!(t instanceof v))throw new Error("ExtendedPoint expected")}class v{constructor(t,e,r,n){if(this.ex=t,this.ey=e,this.ez=r,this.et=n,!g(t))throw new Error("x required");if(!g(e))throw new Error("y required");if(!g(r))throw new Error("z required");if(!g(n))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(t){if(t instanceof v)throw new Error("extended point not allowed");const{x:e,y:r}=t||{};if(!g(e)||!g(r))throw new Error("invalid affine point");return new v(e,r,ar,u(e*r))}static normalizeZ(t){const e=r.invertBatch(t.map((t=>t.ez)));return t.map(((t,r)=>t.toAffine(e[r]))).map(v.fromAffine)}_setWindowSize(t){this._WINDOW_SIZE=t,m.delete(this)}assertValidity(){const{a:t,d:r}=e;if(this.is0())throw new Error("bad point: ZERO");const{ex:n,ey:o,ez:i,et:s}=this,a=u(n*n),c=u(o*o),f=u(i*i),h=u(f*f),d=u(a*t);if(u(f*u(d+c))!==u(h+u(r*u(a*c))))throw new Error("bad point: equation left != right (1)");if(u(n*o)!==u(i*s))throw new Error("bad point: equation left != right (2)")}equals(t){E(t);const{ex:e,ey:r,ez:n}=this,{ex:o,ey:i,ez:s}=t,a=u(e*s),c=u(o*n),f=u(r*s),h=u(i*n);return a===c&&f===h}is0(){return this.equals(v.ZERO)}negate(){return new v(u(-this.ex),this.ey,this.ez,u(-this.et))}double(){const{a:t}=e,{ex:r,ey:n,ez:o}=this,i=u(r*r),s=u(n*n),a=u(cr*u(o*o)),c=u(t*i),f=r+n,h=u(u(f*f)-i-s),d=c+s,l=d-a,p=c-s,y=u(h*l),g=u(d*p),w=u(h*p),b=u(l*d);return new v(y,g,b,w)}add(t){E(t);const{a:r,d:n}=e,{ex:o,ey:i,ez:s,et:a}=this,{ex:c,ey:f,ez:h,et:d}=t;if(r===BigInt(-1)){const t=u((i-o)*(f+c)),e=u((i+o)*(f-c)),r=u(e-t);if(r===sr)return this.double();const n=u(s*cr*d),l=u(a*cr*h),p=l+n,y=e+t,g=l-n,w=u(p*r),b=u(y*g),m=u(p*g),E=u(r*y);return new v(w,b,E,m)}const l=u(o*c),p=u(i*f),y=u(a*n*d),g=u(s*h),w=u((o+i)*(c+f)-l-p),b=g-y,m=g+y,x=u(p-r*l),A=u(w*b),B=u(m*x),S=u(w*x),I=u(b*m);return new v(A,B,I,S)}subtract(t){return this.add(t.negate())}wNAF(t){return B.wNAFCached(this,m,t,v.normalizeZ)}multiply(t){const{p:e,f:r}=this.wNAF(w(t,n));return v.normalizeZ([e,r])[0]}multiplyUnsafe(t){let e=b(t);return e===sr?A:this.equals(A)||e===ar?this:this.equals(x)?this.wNAF(e).p:B.unsafeLadder(this,e)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return B.unsafeLadder(this,n).is0()}toAffine(t){const{ex:e,ey:n,ez:o}=this,i=this.is0();null==t&&(t=i?fr:r.inv(o));const s=u(e*t),a=u(n*t),c=u(o*t);if(i)return{x:sr,y:ar};if(c!==ar)throw new Error("invZ was invalid");return{x:s,y:a}}clearCofactor(){const{h:t}=e;return t===ar?this:this.multiplyUnsafe(t)}static fromHex(t,n=!1){const{d:o,a:i}=e,s=r.BYTES,a=(t=Oe("pointHex",t,s)).slice(),c=t[s-1];a[s-1]=-129&c;const d=ke(a);d===sr||w(d,n?f:r.ORDER);const l=u(d*d),p=u(l-ar),y=u(o*l-i);let{isValid:g,value:b}=h(p,y);if(!g)throw new Error("Point.fromHex: invalid y coordinate");const m=(b&ar)===ar,E=0!=(128&c);if(!n&&b===sr&&E)throw new Error("Point.fromHex: x=0 and x_0=1");return E!==m&&(b=u(-b)),v.fromAffine({x:b,y:d})}static fromPrivateKey(t){return P(t).point}toRawBytes(){const{x:t,y:e}=this.toAffine(),n=Le(e,r.BYTES);return n[n.length-1]|=t&ar?128:0,n}toHex(){return Se(this.toRawBytes())}}v.BASE=new v(e.Gx,e.Gy,ar,u(e.Gx*e.Gy)),v.ZERO=new v(sr,ar,ar,sr);const{BASE:x,ZERO:A}=v,B=or(v,8*a);function S(t){return Fe(t,n)}function I(t){return S(ke(t))}function P(t){const e=a;t=Oe("private key",t,e);const r=Oe("hashed private key",i(t),2*e),n=d(r.slice(0,e)),o=r.slice(e,2*e),s=I(n),c=x.multiply(s),f=c.toRawBytes();return{head:n,prefix:o,scalar:s,point:c,pointBytes:f}}function U(t=new Uint8Array,...e){const r=Re(...e);return I(i(l(r,Oe("context",t),!!o)))}const k=ur;return x._setWindowSize(8),{CURVE:e,getPublicKey:function(t){return P(t).pointBytes},sign:function(t,e,n={}){t=Oe("message",t),o&&(t=o(t));const{prefix:i,scalar:s,pointBytes:c}=P(e),f=U(n.context,i,t),u=x.multiply(f).toRawBytes(),h=S(f+U(n.context,u,c,t)*s);return b(h),Oe("result",Re(u,Le(h,r.BYTES)),2*a)},verify:function(t,e,n,i=k){const{context:s,zip215:a}=i,c=r.BYTES;t=Oe("signature",t,2*c),e=Oe("message",e),o&&(e=o(e));const f=ke(t.slice(c,2*c));let u,h,d;try{u=v.fromHex(n,a),h=v.fromHex(t.slice(0,c),a),d=x.multiplyUnsafe(f)}catch(t){return!1}if(!a&&u.isSmallOrder())return!1;const l=U(s,h.toRawBytes(),u.toRawBytes(),e);return h.add(u.multiplyUnsafe(l)).subtract(d).clearCofactor().equals(v.ZERO)},ExtendedPoint:v,utils:{getExtendedPublicKey:P,randomPrivateKey:()=>s(r.BYTES),precompute:(t=8,e=v.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)}}}const dr=BigInt(0),lr=BigInt(1);const pr=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),yr=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),gr=(BigInt(0),BigInt(1)),wr=BigInt(2),br=BigInt(5),mr=BigInt(10),Er=BigInt(20),vr=BigInt(40),xr=BigInt(80);function Ar(t){const e=pr,r=t*t%e*t%e,n=Ge(r,wr,e)*r%e,o=Ge(n,gr,e)*t%e,i=Ge(o,br,e)*o%e,s=Ge(i,mr,e)*i%e,a=Ge(s,Er,e)*s%e,c=Ge(a,vr,e)*a%e,f=Ge(c,xr,e)*c%e,u=Ge(f,xr,e)*c%e,h=Ge(u,mr,e)*i%e;return{pow_p_5_8:Ge(h,wr,e)*t%e,b2:r}}function Br(t){return t[0]&=248,t[31]&=127,t[31]|=64,t}const Sr=Qe(pr,void 0,!0),Ir=hr({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Sr,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Ee,randomBytes:oe,adjustScalarBytes:Br,uvRatio:function(t,e){const r=pr,n=Fe(e*e*e,r),o=Fe(n*n*e,r);let i=Fe(t*n*Ar(t*o).pow_p_5_8,r);const s=Fe(e*i*i,r),a=i,c=Fe(i*yr,r),f=s===t,u=s===Fe(-t,r),h=s===Fe(-t*yr,r);return f&&(i=a),(u||h)&&(i=c),(Fe(i,r)&He)===He&&(i=Fe(-i,r)),{isValid:f||u,value:i}}});const Pr=(()=>function(t){const e=(_e(r=t,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...r}));var r;const{P:n}=e,o=t=>Fe(t,n),i=e.montgomeryBits,s=Math.ceil(i/8),a=e.nByteLength,c=e.adjustScalarBytes||(t=>t),f=e.powPminus2||(t=>Me(t,n-BigInt(2),n));function u(t,e,r){const n=o(t*(e-r));return[e=o(e-n),r=o(r+n)]}function h(t){if("bigint"==typeof t&&dr<=t&&t<n)return t;throw new Error("Expected valid scalar 0 < scalar < CURVE.P")}const d=(e.a-BigInt(2))/BigInt(4);function l(t){return Le(o(t),s)}function p(t,e){const r=function(t){const e=Oe("u coordinate",t,s);return a===s&&(e[a-1]&=127),ke(e)}(e),n=function(t){const e=Oe("scalar",t);if(e.length!==s&&e.length!==a)throw new Error(`Expected ${s} or ${a} bytes, got ${e.length}`);return ke(c(e))}(t),p=function(t,e){const r=h(t),n=h(e),s=r;let a,c=lr,l=dr,p=r,y=lr,g=dr;for(let t=BigInt(i-1);t>=dr;t--){const e=n>>t&lr;g^=e,a=u(g,c,p),c=a[0],p=a[1],a=u(g,l,y),l=a[0],y=a[1],g=e;const r=c+l,i=o(r*r),f=c-l,h=o(f*f),w=i-h,b=p+y,m=o((p-y)*r),E=o(b*f),v=m+E,x=m-E;p=o(v*v),y=o(s*o(x*x)),c=o(i*h),l=o(w*(i+o(d*w)))}a=u(g,c,p),c=a[0],p=a[1],a=u(g,l,y),l=a[0],y=a[1];const w=f(l);return o(c*w)}(r,n);if(p===dr)throw new Error("Invalid private or public key received");return l(p)}const y=l(e.Gu);function g(t){return p(t,y)}return{scalarMult:p,scalarMultBase:g,getSharedSecret:(t,e)=>p(t,e),getPublicKey:t=>g(t),utils:{randomPrivateKey:()=>e.randomBytes(e.nByteLength)},GuBytes:y}}({P:pr,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:t=>{const e=pr,{pow_p_5_8:r,b2:n}=Ar(t);return Fe(Ge(r,BigInt(3),e)*n,e)},adjustScalarBytes:Br,randomBytes:oe}))(),Ur=(Sr.ORDER+BigInt(3))/BigInt(8);Sr.pow(wr,Ur),Sr.sqrt(Sr.neg(Sr.ONE)),Sr.ORDER,BigInt(5),BigInt(8),BigInt(486662),function(t,e){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const r=t.sqrt(e);t.isOdd(r)&&t.neg(r)}(Sr,Sr.neg(BigInt(486664))),BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");const kr=(t,e,r)=>t&e^t&r^e&r,$r=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Lr=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Or=new Uint32Array(64);class Rr extends ie{constructor(){super(64,32,8,!1),this.A=0|Lr[0],this.B=0|Lr[1],this.C=0|Lr[2],this.D=0|Lr[3],this.E=0|Lr[4],this.F=0|Lr[5],this.G=0|Lr[6],this.H=0|Lr[7]}get(){const{A:t,B:e,C:r,D:n,E:o,F:i,G:s,H:a}=this;return[t,e,r,n,o,i,s,a]}set(t,e,r,n,o,i,s,a){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|a}process(t,e){for(let r=0;r<16;r++,e+=4)Or[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=Or[t-15],r=Or[t-2],n=Yt(e,7)^Yt(e,18)^e>>>3,o=Yt(r,17)^Yt(r,19)^r>>>10;Or[t]=o+Or[t-7]+n+Or[t-16]|0}let{A:r,B:n,C:o,D:i,E:s,F:a,G:c,H:f}=this;for(let t=0;t<64;t++){const e=f+(Yt(s,6)^Yt(s,11)^Yt(s,25))+((u=s)&a^~u&c)+$r[t]+Or[t]|0,h=(Yt(r,2)^Yt(r,13)^Yt(r,22))+kr(r,n,o)|0;f=c,c=a,a=s,s=i+e|0,i=o,o=n,n=r,r=e+h|0}var u;r=r+this.A|0,n=n+this.B|0,o=o+this.C|0,i=i+this.D|0,s=s+this.E|0,a=a+this.F|0,c=c+this.G|0,f=f+this.H|0,this.set(r,n,o,i,s,a,c,f)}roundClean(){Or.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Tr=ne((()=>new Rr)),Nr=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),Cr=Uint8Array.from({length:16},((t,e)=>e));let Dr=[Cr],Kr=[Cr.map((t=>(9*t+5)%16))];for(let t=0;t<4;t++)for(let e of[Dr,Kr])e.push(e[t].map((t=>Nr[t])));const _r=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map((t=>new Uint8Array(t))),jr=Dr.map(((t,e)=>t.map((t=>_r[e][t])))),Hr=Kr.map(((t,e)=>t.map((t=>_r[e][t])))),Wr=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),Jr=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]),qr=(t,e)=>t<<e|t>>>32-e;function Vr(t,e,r,n){return 0===t?e^r^n:1===t?e&r|~e&n:2===t?(e|~r)^n:3===t?e&n|r&~n:e^(r|~n)}const zr=new Uint32Array(16);class Fr extends ie{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:e,h2:r,h3:n,h4:o}=this;return[t,e,r,n,o]}set(t,e,r,n,o){this.h0=0|t,this.h1=0|e,this.h2=0|r,this.h3=0|n,this.h4=0|o}process(t,e){for(let r=0;r<16;r++,e+=4)zr[r]=t.getUint32(e,!0);let r=0|this.h0,n=r,o=0|this.h1,i=o,s=0|this.h2,a=s,c=0|this.h3,f=c,u=0|this.h4,h=u;for(let t=0;t<5;t++){const e=4-t,d=Wr[t],l=Jr[t],p=Dr[t],y=Kr[t],g=jr[t],w=Hr[t];for(let e=0;e<16;e++){const n=qr(r+Vr(t,o,s,c)+zr[p[e]]+d,g[e])+u|0;r=u,u=c,c=0|qr(s,10),s=o,o=n}for(let t=0;t<16;t++){const r=qr(n+Vr(e,i,a,f)+zr[y[t]]+l,w[t])+h|0;n=h,h=f,f=0|qr(a,10),a=i,i=r}}this.set(this.h1+s+f|0,this.h2+c+h|0,this.h3+u+n|0,this.h4+r+i|0,this.h0+o+a|0)}roundClean(){zr.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}const Mr=ne((()=>new Fr)),[Gr,Zr,Xr]=[[],[],[]],Yr=BigInt(0),Qr=BigInt(1),tn=BigInt(2),en=BigInt(7),rn=BigInt(256),nn=BigInt(113);for(let t=0,e=Qr,r=1,n=0;t<24;t++){[r,n]=[n,(2*r+3*n)%5],Gr.push(2*(5*n+r)),Zr.push((t+1)*(t+2)/2%64);let o=Yr;for(let t=0;t<7;t++)e=(e<<Qr^(e>>en)*nn)%rn,e&tn&&(o^=Qr<<(Qr<<BigInt(t))-Qr);Xr.push(o)}const[on,sn]=fe(Xr,!0),an=(t,e,r)=>r>32?de(t,e,r):ue(t,e,r),cn=(t,e,r)=>r>32?le(t,e,r):he(t,e,r);class fn extends re{constructor(t,e,r,n=!1,o=24){if(super(),this.blockLen=t,this.suffix=e,this.outputLen=r,this.enableXOF=n,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Vt(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var i;this.state=new Uint8Array(200),this.state32=(i=this.state,new Uint32Array(i.buffer,i.byteOffset,Math.floor(i.byteLength/4)))}keccak(){!function(t,e=24){const r=new Uint32Array(10);for(let n=24-e;n<24;n++){for(let e=0;e<10;e++)r[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){const n=(e+8)%10,o=(e+2)%10,i=r[o],s=r[o+1],a=an(i,s,1)^r[n],c=cn(i,s,1)^r[n+1];for(let r=0;r<50;r+=10)t[e+r]^=a,t[e+r+1]^=c}let e=t[2],o=t[3];for(let r=0;r<24;r++){const n=Zr[r],i=an(e,o,n),s=cn(e,o,n),a=Gr[r];e=t[a],o=t[a+1],t[a]=i,t[a+1]=s}for(let e=0;e<50;e+=10){for(let n=0;n<10;n++)r[n]=t[e+n];for(let n=0;n<10;n++)t[e+n]^=~r[(n+2)%10]&r[(n+4)%10]}t[0]^=on[n],t[1]^=sn[n]}r.fill(0)}(this.state32,this.rounds),this.posOut=0,this.pos=0}update(t){Ft(this);const{blockLen:e,state:r}=this,n=(t=te(t)).length;for(let o=0;o<n;){const i=Math.min(e-this.pos,n-o);for(let e=0;e<i;e++)r[this.pos++]^=t[o++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:r,blockLen:n}=this;t[r]^=e,0!=(128&e)&&r===n-1&&this.keccak(),t[n-1]^=128,this.keccak()}writeInto(t){Ft(this,!1),zt(t),this.finish();const e=this.state,{blockLen:r}=this;for(let n=0,o=t.length;n<o;){this.posOut>=r&&this.keccak();const i=Math.min(r-this.posOut,o-n);t.set(e.subarray(this.posOut,this.posOut+i),n),this.posOut+=i,n+=i}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return Vt(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(Mt(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:e,suffix:r,outputLen:n,rounds:o,enableXOF:i}=this;return t||(t=new fn(e,r,n,i,o)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=o,t.suffix=r,t.outputLen=n,t.enableXOF=i,t.destroyed=this.destroyed,t}}const un=((t,e,r)=>ne((()=>new fn(e,t,r))))(1,136,32);class hn extends re{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");Vt(t.outputLen),Vt(t.blockLen)}(t);const r=te(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,o=new Uint8Array(n);o.set(r.length>n?t.create().update(r).digest():r);for(let t=0;t<o.length;t++)o[t]^=54;this.iHash.update(o),this.oHash=t.create();for(let t=0;t<o.length;t++)o[t]^=106;this.oHash.update(o),o.fill(0)}update(t){return Ft(this),this.iHash.update(t),this}digestInto(t){Ft(this),zt(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:o,blockLen:i,outputLen:s}=this;return t.finished=n,t.destroyed=o,t.blockLen=i,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const dn=(t,e,r)=>new hn(t,e).update(r).digest();dn.create=(t,e)=>new hn(t,e);const{bytesToNumberBE:ln,hexToBytes:pn}=g,yn={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(t){const{Err:e}=yn;if(t.length<2||2!==t[0])throw new e("Invalid signature integer tag");const r=t[1],n=t.subarray(2,r+2);if(!r||n.length!==r)throw new e("Invalid signature integer: wrong length");if(128&n[0])throw new e("Invalid signature integer: negative");if(0===n[0]&&!(128&n[1]))throw new e("Invalid signature integer: unnecessary leading zero");return{d:ln(n),l:t.subarray(r+2)}},toSig(t){const{Err:e}=yn,r="string"==typeof t?pn(t):t;if(!(r instanceof Uint8Array))throw new Error("ui8a expected");let n=r.length;if(n<2||48!=r[0])throw new e("Invalid signature tag");if(r[1]!==n-2)throw new e("Invalid signature: incorrect length");const{d:o,l:i}=yn._parseInt(r.subarray(2)),{d:s,l:a}=yn._parseInt(i);if(a.length)throw new e("Invalid signature: left bytes after parsing");return{r:o,s}},hexFromSig(t){const e=t=>8&Number.parseInt(t[0],16)?"00"+t:t,r=t=>{const e=t.toString(16);return 1&e.length?`0${e}`:e},n=e(r(t.s)),o=e(r(t.r)),i=n.length/2,s=o.length/2,a=r(i),c=r(s);return`30${r(s+i+4)}02${c}${o}02${a}${n}`}},gn=BigInt(0),wn=BigInt(1),bn=(BigInt(2),BigInt(3));function mn(t){const e=function(t){const e=ir(t);return _e(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:r,n}=e,o=r.BYTES+1,i=2*r.BYTES+1;function s(t){return Fe(t,n)}function a(t){return Ze(t,n)}const{ProjectivePoint:c,normPrivateKeyToScalar:f,weierstrassEquation:u,isWithinCurveOrder:h}=function(t){const e=function(t){const e=ir(t);_e(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:o}=e;if(r){if(!n.eql(o,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:r}=e,n=e.toBytes||((t,e,n)=>{const o=e.toAffine();return Re(Uint8Array.from([4]),r.toBytes(o.x),r.toBytes(o.y))}),o=e.fromBytes||(t=>{const e=t.subarray(1);return{x:r.fromBytes(e.subarray(0,r.BYTES)),y:r.fromBytes(e.subarray(r.BYTES,2*r.BYTES))}});function i(t){const{a:n,b:o}=e,i=r.sqr(t),s=r.mul(i,t);return r.add(r.add(s,r.mul(t,n)),o)}if(!r.eql(r.sqr(e.Gy),i(e.Gx)))throw new Error("bad generator point: equation left != right");function s(t){return"bigint"==typeof t&&gn<t&&t<e.n}function a(t){if(!s(t))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(t){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:o,n:i}=e;if(r&&"bigint"!=typeof t){if(t instanceof Uint8Array&&(t=Se(t)),"string"!=typeof t||!r.includes(t.length))throw new Error("Invalid key");t=t.padStart(2*n,"0")}let s;try{s="bigint"==typeof t?t:Ue(Oe("private key",t,n))}catch(e){throw new Error(`private key must be ${n} bytes, hex or bigint, not ${typeof t}`)}return o&&(s=Fe(s,i)),a(s),s}const f=new Map;function u(t){if(!(t instanceof h))throw new Error("ProjectivePoint expected")}class h{constructor(t,e,n){if(this.px=t,this.py=e,this.pz=n,null==t||!r.isValid(t))throw new Error("x required");if(null==e||!r.isValid(e))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required")}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw new Error("invalid affine point");if(t instanceof h)throw new Error("projective point not allowed");const o=t=>r.eql(t,r.ZERO);return o(e)&&o(n)?h.ZERO:new h(e,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(h.fromAffine)}static fromHex(t){const e=h.fromAffine(o(Oe("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return h.BASE.multiply(c(t))}_setWindowSize(t){this._WINDOW_SIZE=t,f.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:t,y:n}=this.toAffine();if(!r.isValid(t)||!r.isValid(n))throw new Error("bad point: x or y not FE");const o=r.sqr(n),s=i(t);if(!r.eql(o,s))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){u(t);const{px:e,py:n,pz:o}=this,{px:i,py:s,pz:a}=t,c=r.eql(r.mul(e,a),r.mul(i,o)),f=r.eql(r.mul(n,a),r.mul(s,o));return c&&f}negate(){return new h(this.px,r.neg(this.py),this.pz)}double(){const{a:t,b:n}=e,o=r.mul(n,bn),{px:i,py:s,pz:a}=this;let c=r.ZERO,f=r.ZERO,u=r.ZERO,d=r.mul(i,i),l=r.mul(s,s),p=r.mul(a,a),y=r.mul(i,s);return y=r.add(y,y),u=r.mul(i,a),u=r.add(u,u),c=r.mul(t,u),f=r.mul(o,p),f=r.add(c,f),c=r.sub(l,f),f=r.add(l,f),f=r.mul(c,f),c=r.mul(y,c),u=r.mul(o,u),p=r.mul(t,p),y=r.sub(d,p),y=r.mul(t,y),y=r.add(y,u),u=r.add(d,d),d=r.add(u,d),d=r.add(d,p),d=r.mul(d,y),f=r.add(f,d),p=r.mul(s,a),p=r.add(p,p),d=r.mul(p,y),c=r.sub(c,d),u=r.mul(p,l),u=r.add(u,u),u=r.add(u,u),new h(c,f,u)}add(t){u(t);const{px:n,py:o,pz:i}=this,{px:s,py:a,pz:c}=t;let f=r.ZERO,d=r.ZERO,l=r.ZERO;const p=e.a,y=r.mul(e.b,bn);let g=r.mul(n,s),w=r.mul(o,a),b=r.mul(i,c),m=r.add(n,o),E=r.add(s,a);m=r.mul(m,E),E=r.add(g,w),m=r.sub(m,E),E=r.add(n,i);let v=r.add(s,c);return E=r.mul(E,v),v=r.add(g,b),E=r.sub(E,v),v=r.add(o,i),f=r.add(a,c),v=r.mul(v,f),f=r.add(w,b),v=r.sub(v,f),l=r.mul(p,E),f=r.mul(y,b),l=r.add(f,l),f=r.sub(w,l),l=r.add(w,l),d=r.mul(f,l),w=r.add(g,g),w=r.add(w,g),b=r.mul(p,b),E=r.mul(y,E),w=r.add(w,b),b=r.sub(g,b),b=r.mul(p,b),E=r.add(E,b),g=r.mul(w,E),d=r.add(d,g),g=r.mul(v,E),f=r.mul(m,f),f=r.sub(f,g),g=r.mul(m,w),l=r.mul(v,l),l=r.add(l,g),new h(f,d,l)}subtract(t){return this.add(t.negate())}is0(){return this.equals(h.ZERO)}wNAF(t){return l.wNAFCached(this,f,t,(t=>{const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(h.fromAffine)}))}multiplyUnsafe(t){const n=h.ZERO;if(t===gn)return n;if(a(t),t===wn)return this;const{endo:o}=e;if(!o)return l.unsafeLadder(this,t);let{k1neg:i,k1:s,k2neg:c,k2:f}=o.splitScalar(t),u=n,d=n,p=this;for(;s>gn||f>gn;)s&wn&&(u=u.add(p)),f&wn&&(d=d.add(p)),p=p.double(),s>>=wn,f>>=wn;return i&&(u=u.negate()),c&&(d=d.negate()),d=new h(r.mul(d.px,o.beta),d.py,d.pz),u.add(d)}multiply(t){a(t);let n,o,i=t;const{endo:s}=e;if(s){const{k1neg:t,k1:e,k2neg:a,k2:c}=s.splitScalar(i);let{p:f,f:u}=this.wNAF(e),{p:d,f:p}=this.wNAF(c);f=l.constTimeNegate(t,f),d=l.constTimeNegate(a,d),d=new h(r.mul(d.px,s.beta),d.py,d.pz),n=f.add(d),o=u.add(p)}else{const{p:t,f:e}=this.wNAF(i);n=t,o=e}return h.normalizeZ([n,o])[0]}multiplyAndAddUnsafe(t,e,r){const n=h.BASE,o=(t,e)=>e!==gn&&e!==wn&&t.equals(n)?t.multiply(e):t.multiplyUnsafe(e),i=o(this,e).add(o(t,r));return i.is0()?void 0:i}toAffine(t){const{px:e,py:n,pz:o}=this,i=this.is0();null==t&&(t=i?r.ONE:r.inv(o));const s=r.mul(e,t),a=r.mul(n,t),c=r.mul(o,t);if(i)return{x:r.ZERO,y:r.ZERO};if(!r.eql(c,r.ONE))throw new Error("invZ was invalid");return{x:s,y:a}}isTorsionFree(){const{h:t,isTorsionFree:r}=e;if(t===wn)return!0;if(r)return r(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:r}=e;return t===wn?this:r?r(h,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return this.assertValidity(),n(h,this,t)}toHex(t=!0){return Se(this.toRawBytes(t))}}h.BASE=new h(e.Gx,e.Gy,r.ONE),h.ZERO=new h(r.ZERO,r.ONE,r.ZERO);const d=e.nBitLength,l=or(h,e.endo?Math.ceil(d/2):d);return{CURVE:e,ProjectivePoint:h,normPrivateKeyToScalar:c,weierstrassEquation:i,isWithinCurveOrder:s}}({...e,toBytes(t,e,n){const o=e.toAffine(),i=r.toBytes(o.x),s=Re;return n?s(Uint8Array.from([e.hasEvenY()?2:3]),i):s(Uint8Array.from([4]),i,r.toBytes(o.y))},fromBytes(t){const e=t.length,n=t[0],s=t.subarray(1);if(e!==o||2!==n&&3!==n){if(e===i&&4===n)return{x:r.fromBytes(s.subarray(0,r.BYTES)),y:r.fromBytes(s.subarray(r.BYTES,2*r.BYTES))};throw new Error(`Point of length ${e} was invalid. Expected ${o} compressed bytes or ${i} uncompressed bytes`)}{const t=Ue(s);if(!(gn<(a=t)&&a<r.ORDER))throw new Error("Point is not on curve");const e=u(t);let o=r.sqrt(e);return 1==(1&n)!=((o&wn)===wn)&&(o=r.neg(o)),{x:t,y:o}}var a}}),d=t=>Se($e(t,e.nByteLength));function l(t){return t>n>>wn}const p=(t,e,r)=>Ue(t.slice(e,r));class y{constructor(t,e,r){this.r=t,this.s=e,this.recovery=r,this.assertValidity()}static fromCompact(t){const r=e.nByteLength;return t=Oe("compactSignature",t,2*r),new y(p(t,0,r),p(t,r,2*r))}static fromDER(t){const{r:e,s:r}=yn.toSig(Oe("DER",t));return new y(e,r)}assertValidity(){if(!h(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!h(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(t){return new y(this.r,this.s,t)}recoverPublicKey(t){const{r:n,s:o,recovery:i}=this,f=m(Oe("msgHash",t));if(null==i||![0,1,2,3].includes(i))throw new Error("recovery id invalid");const u=2===i||3===i?n+e.n:n;if(u>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const h=0==(1&i)?"02":"03",l=c.fromHex(h+d(u)),p=a(u),y=s(-f*p),g=s(o*p),w=c.BASE.multiplyAndAddUnsafe(l,y,g);if(!w)throw new Error("point at infinify");return w.assertValidity(),w}hasHighS(){return l(this.s)}normalizeS(){return this.hasHighS()?new y(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return Pe(this.toDERHex())}toDERHex(){return yn.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Pe(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}const g={isValidPrivateKey(t){try{return f(t),!0}catch(t){return!1}},normPrivateKeyToScalar:f,randomPrivateKey:()=>{const t=er(e.n);return function(t,e,r=!1){const n=t.length,o=tr(e),i=er(e);if(n<16||n<i||n>1024)throw new Error(`expected ${i}-1024 bytes of input, got ${n}`);const s=Fe(r?Ue(t):ke(t),e-He)+He;return r?Le(s,o):$e(s,o)}(e.randomBytes(t),e.n)},precompute:(t=8,e=c.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function w(t){const e=t instanceof Uint8Array,r="string"==typeof t,n=(e||r)&&t.length;return e?n===o||n===i:r?n===2*o||n===2*i:t instanceof c}const b=e.bits2int||function(t){const r=Ue(t),n=8*t.length-e.nBitLength;return n>0?r>>BigInt(n):r},m=e.bits2int_modN||function(t){return s(b(t))},E=Te(e.nBitLength);function v(t){if("bigint"!=typeof t)throw new Error("bigint expected");if(!(gn<=t&&t<E))throw new Error(`bigint expected < 2^${e.nBitLength}`);return $e(t,e.nByteLength)}const x={lowS:e.lowS,prehash:!1},A={lowS:e.lowS,prehash:!1};return c.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return c.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,r=!0){if(w(t))throw new Error("first arg must be private key");if(!w(e))throw new Error("second arg must be public key");return c.fromHex(e).multiply(f(t)).toRawBytes(r)},sign:function(t,n,o=x){const{seed:i,k2sig:u}=function(t,n,o=x){if(["recovered","canonical"].some((t=>t in o)))throw new Error("sign() legacy options not supported");const{hash:i,randomBytes:u}=e;let{lowS:d,prehash:p,extraEntropy:g}=o;null==d&&(d=!0),t=Oe("msgHash",t),p&&(t=Oe("prehashed msgHash",i(t)));const w=m(t),E=f(n),A=[v(E),v(w)];if(null!=g){const t=!0===g?u(r.BYTES):g;A.push(Oe("extraEntropy",t))}const B=Re(...A),S=w;return{seed:B,k2sig:function(t){const e=b(t);if(!h(e))return;const r=a(e),n=c.BASE.multiply(e).toAffine(),o=s(n.x);if(o===gn)return;const i=s(r*s(S+o*E));if(i===gn)return;let f=(n.x===o?0:2)|Number(n.y&wn),u=i;return d&&l(i)&&(u=function(t){return l(t)?s(-t):t}(i),f^=1),new y(o,u,f)}}}(t,n,o),d=e;return De(d.hash.outputLen,d.nByteLength,d.hmac)(i,u)},verify:function(t,r,n,o=A){const i=t;if(r=Oe("msgHash",r),n=Oe("publicKey",n),"strict"in o)throw new Error("options.strict was renamed to lowS");const{lowS:f,prehash:u}=o;let h,d;try{if("string"==typeof i||i instanceof Uint8Array)try{h=y.fromDER(i)}catch(t){if(!(t instanceof yn.Err))throw t;h=y.fromCompact(i)}else{if("object"!=typeof i||"bigint"!=typeof i.r||"bigint"!=typeof i.s)throw new Error("PARSE");{const{r:t,s:e}=i;h=new y(t,e)}}d=c.fromHex(n)}catch(t){if("PARSE"===t.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(f&&h.hasHighS())return!1;u&&(r=e.hash(r));const{r:l,s:p}=h,g=m(r),w=a(p),b=s(g*w),E=s(l*w),v=c.BASE.multiplyAndAddUnsafe(d,b,E)?.toAffine();return!!v&&s(v.x)===l},ProjectivePoint:c,Signature:y,utils:g}}function En(t){return{hash:t,hmac:(e,...r)=>dn(t,e,ee(...r)),randomBytes:oe}}function vn(t,e){const r=e=>mn({...t,...En(e)});return Object.freeze({...r(e),create:r})}BigInt(4);const xn=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),An=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Bn=BigInt(1),Sn=BigInt(2),In=(t,e)=>(t+e/Sn)/e;const Pn=Qe(xn,void 0,void 0,{sqrt:function(t){const e=xn,r=BigInt(3),n=BigInt(6),o=BigInt(11),i=BigInt(22),s=BigInt(23),a=BigInt(44),c=BigInt(88),f=t*t*t%e,u=f*f*t%e,h=Ge(u,r,e)*u%e,d=Ge(h,r,e)*u%e,l=Ge(d,Sn,e)*f%e,p=Ge(l,o,e)*l%e,y=Ge(p,i,e)*p%e,g=Ge(y,a,e)*y%e,w=Ge(g,c,e)*g%e,b=Ge(w,a,e)*y%e,m=Ge(b,r,e)*u%e,E=Ge(m,s,e)*p%e,v=Ge(E,n,e)*f%e,x=Ge(v,Sn,e);if(!Pn.eql(Pn.sqr(x),t))throw new Error("Cannot find square root");return x}}),Un=vn({a:BigInt(0),b:BigInt(7),Fp:Pn,n:An,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=An,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Bn*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=r,s=BigInt("0x100000000000000000000000000000000"),a=In(i*t,e),c=In(-n*t,e);let f=Fe(t-a*r-c*o,e),u=Fe(-a*n-c*i,e);const h=f>s,d=u>s;if(h&&(f=e-f),d&&(u=e-u),f>s||u>s)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:h,k1:f,k2neg:d,k2:u}}}},Tr);BigInt(0),Un.ProjectivePoint;const kn=Qe(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),$n=vn({a:kn.create(BigInt("-3")),b:BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Fp:kn,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},Tr);var Ln=r(456);const On="(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))",Rn="[a-zA-Z0-9_.:%-]",Tn=new RegExp(`^did:([a-z0-9]+):((?:${On}*:)*(${On}+))((;${Rn}+=${Rn}*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$`);function Nn(t){if(!Number.isSafeInteger(t))throw new Error(`Wrong integer: ${t}`)}function Cn(...t){const e=(t,e)=>r=>t(e(r));return{encode:Array.from(t).reverse().reduce(((t,r)=>t?e(t,r.encode):r.encode),void 0),decode:t.reduce(((t,r)=>t?e(t,r.decode):r.decode),void 0)}}function Dn(t){return{encode:e=>{if(!Array.isArray(e)||e.length&&"number"!=typeof e[0])throw new Error("alphabet.encode input should be an array of numbers");return e.map((e=>{if(Nn(e),e<0||e>=t.length)throw new Error(`Digit index outside alphabet: ${e} (alphabet: ${t.length})`);return t[e]}))},decode:e=>{if(!Array.isArray(e)||e.length&&"string"!=typeof e[0])throw new Error("alphabet.decode input should be array of strings");return e.map((e=>{if("string"!=typeof e)throw new Error(`alphabet.decode: not string element=${e}`);const r=t.indexOf(e);if(-1===r)throw new Error(`Unknown letter: "${e}". Allowed: ${t}`);return r}))}}}function Kn(t=""){if("string"!=typeof t)throw new Error("join separator should be string");return{encode:e=>{if(!Array.isArray(e)||e.length&&"string"!=typeof e[0])throw new Error("join.encode input should be array of strings");for(let t of e)if("string"!=typeof t)throw new Error(`join.encode: non-string input=${t}`);return e.join(t)},decode:e=>{if("string"!=typeof e)throw new Error("join.decode input should be string");return e.split(t)}}}function _n(t,e="="){if(Nn(t),"string"!=typeof e)throw new Error("padding chr should be string");return{encode(r){if(!Array.isArray(r)||r.length&&"string"!=typeof r[0])throw new Error("padding.encode input should be array of strings");for(let t of r)if("string"!=typeof t)throw new Error(`padding.encode: non-string input=${t}`);for(;r.length*t%8;)r.push(e);return r},decode(r){if(!Array.isArray(r)||r.length&&"string"!=typeof r[0])throw new Error("padding.encode input should be array of strings");for(let t of r)if("string"!=typeof t)throw new Error(`padding.decode: non-string input=${t}`);let n=r.length;if(n*t%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;n>0&&r[n-1]===e;n--)if(!((n-1)*t%8))throw new Error("Invalid padding: string has too much padding");return r.slice(0,n)}}}function jn(t){if("function"!=typeof t)throw new Error("normalize fn should be function");return{encode:t=>t,decode:e=>t(e)}}function Hn(t,e,r){if(e<2)throw new Error(`convertRadix: wrong from=${e}, base cannot be less than 2`);if(r<2)throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);if(!Array.isArray(t))throw new Error("convertRadix: data should be array");if(!t.length)return[];let n=0;const o=[],i=Array.from(t);for(i.forEach((t=>{if(Nn(t),t<0||t>=e)throw new Error(`Wrong integer: ${t}`)}));;){let t=0,s=!0;for(let o=n;o<i.length;o++){const n=i[o],a=e*t+n;if(!Number.isSafeInteger(a)||e*t/e!==t||a-n!=e*t)throw new Error("convertRadix: carry overflow");a%r;const c=Math.floor(a/r);if(i[o]=c,!Number.isSafeInteger(c)||c*r+t!==a)throw new Error("convertRadix: carry overflow");s&&(c?!1:o)}if(o.push(t),s)break}for(let e=0;e<t.length-1&&0===t[e];e++)o.push(0);return o.reverse()}const Wn=(t,e)=>e?Wn(e,t%e):t,Jn=(t,e)=>t+(e-Wn(t,e));function qn(t,e,r,n){if(!Array.isArray(t))throw new Error("convertRadix2: data should be array");if(e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(r<=0||r>32)throw new Error(`convertRadix2: wrong to=${r}`);if(Jn(e,r)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${r} carryBits=${Jn(e,r)}`);let o=0,i=0;const s=2**r-1,a=[];for(const n of t){if(Nn(n),n>=2**e)throw new Error(`convertRadix2: invalid data word=${n} from=${e}`);if(o=o<<e|n,i+e>32)throw new Error(`convertRadix2: carry overflow pos=${i} from=${e}`);for(i+=e;i>=r;i-=r)a.push((o>>i-r&s)>>>0);o&=2**i-1}if(o=o<<r-i&s,!n&&i>=e)throw new Error("Excess padding");if(!n&&o)throw new Error(`Non-zero padding: ${o}`);return n&&i>0&&a.push(o>>>0),a}function Vn(t,e=!1){if(Nn(t),t<=0||t>32)throw new Error("radix2: bits should be in (0..32]");if(Jn(8,t)>32||Jn(t,8)>32)throw new Error("radix2: carry overflow");return{encode:r=>{if(!(r instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return qn(Array.from(r),8,t,!e)},decode:r=>{if(!Array.isArray(r)||r.length&&"number"!=typeof r[0])throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(qn(r,t,8,e))}}}function zn(t){if("function"!=typeof t)throw new Error("unsafeWrapper fn should be function");return function(...e){try{return t.apply(null,e)}catch(t){}}}Vn(4),Dn("0123456789ABCDEF"),Kn(""),Vn(5),Dn("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),_n(5),Kn(""),Vn(5),Dn("0123456789ABCDEFGHIJKLMNOPQRSTUV"),_n(5),Kn(""),Vn(5),Dn("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),Kn(""),jn((t=>t.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1"))),Vn(6),Dn("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),_n(6),Kn(""),Vn(6),Dn("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),_n(6),Kn(""),Vn(6),Dn("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),Kn("");const Fn=Cn(Dn("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),Kn("")),Mn=[996825010,642813549,513874426,1027748829,705979059];function Gn(t){const e=t>>25;let r=(33554431&t)<<5;for(let t=0;t<Mn.length;t++)1==(e>>t&1)&&(r^=Mn[t]);return r}function Zn(t,e,r=1){const n=t.length;let o=1;for(let e=0;e<n;e++){const r=t.charCodeAt(e);if(r<33||r>126)throw new Error(`Invalid prefix (${t})`);o=Gn(o)^r>>5}o=Gn(o);for(let e=0;e<n;e++)o=Gn(o)^31&t.charCodeAt(e);for(let t of e)o=Gn(o)^t;for(let t=0;t<6;t++)o=Gn(o);return o^=r,Fn.encode(qn([o%2**30],30,5,!1))}function Xn(t){const e="bech32"===t?1:734539939,r=Vn(5),n=r.decode,o=r.encode,i=zn(n);function s(t,r=90){if("string"!=typeof t)throw new Error("bech32.decode input should be string, not "+typeof t);if(t.length<8||!1!==r&&t.length>r)throw new TypeError(`Wrong string length: ${t.length} (${t}). Expected (8..${r})`);const n=t.toLowerCase();if(t!==n&&t!==t.toUpperCase())throw new Error("String must be lowercase or uppercase");const o=(t=n).lastIndexOf("1");if(0===o||-1===o)throw new Error('Letter "1" must be present between prefix and data only');const i=t.slice(0,o),s=t.slice(o+1);if(s.length<6)throw new Error("Data must be at least 6 characters long");const a=Fn.decode(s).slice(0,-6),c=Zn(i,a,e);if(!s.endsWith(c))throw new Error(`Invalid checksum in ${t}: expected "${c}"`);return{prefix:i,words:a}}return{encode:function(t,r,n=90){if("string"!=typeof t)throw new Error("bech32.encode prefix should be string, not "+typeof t);if(!Array.isArray(r)||r.length&&"number"!=typeof r[0])throw new Error("bech32.encode words should be array of numbers, not "+typeof r);const o=t.length+7+r.length;if(!1!==n&&o>n)throw new TypeError(`Length ${o} exceeds limit ${n}`);const i=t.toLowerCase(),s=Zn(i,r,e);return`${i}1${Fn.encode(r)}${s}`},decode:s,decodeToBytes:function(t){const{prefix:e,words:r}=s(t,!1);return{prefix:e,words:r,bytes:n(r)}},decodeUnsafe:zn(s),fromWords:n,fromWordsUnsafe:i,toWords:o}}const Yn=Xn("bech32"),Qn=(Vn(4),Dn("0123456789abcdef"),Kn(""),jn((t=>{if("string"!=typeof t||t.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof t} with length ${t.length}`);return t.toLowerCase()})),t=>t instanceof Uint8Array),to=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4));if(68!==new Uint8Array(new Uint32Array([287454020]).buffer)[0])throw new Error("Non little-endian hardware is not supported");function eo(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}function ro(t){if("string"==typeof t&&(t=eo(t)),!Qn(t))throw new Error("expected Uint8Array, got "+typeof t);return t}function no(t,e){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected");if("number"==typeof e&&t.length!==e)throw new Error(`Uint8Array length ${e} expected`)}function oo(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const o=BigInt(32),i=BigInt(4294967295),s=Number(r>>o&i),a=Number(r&i),c=n?4:0,f=n?0:4;t.setUint32(e+c,s,n),t.setUint32(e+f,a,n)}function io(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function so(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}const ao={number:io,bool:function(t){if("boolean"!=typeof t)throw new Error(`Expected boolean, not ${t}`)},bytes:so,hash:function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("hash must be wrapped by utils.wrapConstructor");io(t.outputLen),io(t.blockLen)},exists:function(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")},output:function(t,e){so(t);const r=e.outputLen;if(t.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}},co=(t,e)=>255&t[e++]|(255&t[e++])<<8;class fo{constructor(t){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,no(t=ro(t),32);const e=co(t,0),r=co(t,2),n=co(t,4),o=co(t,6),i=co(t,8),s=co(t,10),a=co(t,12),c=co(t,14);this.r[0]=8191&e,this.r[1]=8191&(e>>>13|r<<3),this.r[2]=7939&(r>>>10|n<<6),this.r[3]=8191&(n>>>7|o<<9),this.r[4]=255&(o>>>4|i<<12),this.r[5]=i>>>1&8190,this.r[6]=8191&(i>>>14|s<<2),this.r[7]=8065&(s>>>11|a<<5),this.r[8]=8191&(a>>>8|c<<8),this.r[9]=c>>>5&127;for(let e=0;e<8;e++)this.pad[e]=co(t,16+2*e)}process(t,e,r=!1){const n=r?0:2048,{h:o,r:i}=this,s=i[0],a=i[1],c=i[2],f=i[3],u=i[4],h=i[5],d=i[6],l=i[7],p=i[8],y=i[9],g=co(t,e+0),w=co(t,e+2),b=co(t,e+4),m=co(t,e+6),E=co(t,e+8),v=co(t,e+10),x=co(t,e+12),A=co(t,e+14);let B=o[0]+(8191&g),S=o[1]+(8191&(g>>>13|w<<3)),I=o[2]+(8191&(w>>>10|b<<6)),P=o[3]+(8191&(b>>>7|m<<9)),U=o[4]+(8191&(m>>>4|E<<12)),k=o[5]+(E>>>1&8191),$=o[6]+(8191&(E>>>14|v<<2)),L=o[7]+(8191&(v>>>11|x<<5)),O=o[8]+(8191&(x>>>8|A<<8)),R=o[9]+(A>>>5|n),T=0,N=T+B*s+S*(5*y)+I*(5*p)+P*(5*l)+U*(5*d);T=N>>>13,N&=8191,N+=k*(5*h)+$*(5*u)+L*(5*f)+O*(5*c)+R*(5*a),T+=N>>>13,N&=8191;let C=T+B*a+S*s+I*(5*y)+P*(5*p)+U*(5*l);T=C>>>13,C&=8191,C+=k*(5*d)+$*(5*h)+L*(5*u)+O*(5*f)+R*(5*c),T+=C>>>13,C&=8191;let D=T+B*c+S*a+I*s+P*(5*y)+U*(5*p);T=D>>>13,D&=8191,D+=k*(5*l)+$*(5*d)+L*(5*h)+O*(5*u)+R*(5*f),T+=D>>>13,D&=8191;let K=T+B*f+S*c+I*a+P*s+U*(5*y);T=K>>>13,K&=8191,K+=k*(5*p)+$*(5*l)+L*(5*d)+O*(5*h)+R*(5*u),T+=K>>>13,K&=8191;let _=T+B*u+S*f+I*c+P*a+U*s;T=_>>>13,_&=8191,_+=k*(5*y)+$*(5*p)+L*(5*l)+O*(5*d)+R*(5*h),T+=_>>>13,_&=8191;let j=T+B*h+S*u+I*f+P*c+U*a;T=j>>>13,j&=8191,j+=k*s+$*(5*y)+L*(5*p)+O*(5*l)+R*(5*d),T+=j>>>13,j&=8191;let H=T+B*d+S*h+I*u+P*f+U*c;T=H>>>13,H&=8191,H+=k*a+$*s+L*(5*y)+O*(5*p)+R*(5*l),T+=H>>>13,H&=8191;let W=T+B*l+S*d+I*h+P*u+U*f;T=W>>>13,W&=8191,W+=k*c+$*a+L*s+O*(5*y)+R*(5*p),T+=W>>>13,W&=8191;let J=T+B*p+S*l+I*d+P*h+U*u;T=J>>>13,J&=8191,J+=k*f+$*c+L*a+O*s+R*(5*y),T+=J>>>13,J&=8191;let q=T+B*y+S*p+I*l+P*d+U*h;T=q>>>13,q&=8191,q+=k*u+$*f+L*c+O*a+R*s,T+=q>>>13,q&=8191,T=(T<<2)+T|0,T=T+N|0,N=8191&T,T>>>=13,C+=T,o[0]=N,o[1]=C,o[2]=D,o[3]=K,o[4]=_,o[5]=j,o[6]=H,o[7]=W,o[8]=J,o[9]=q}finalize(){const{h:t,pad:e}=this,r=new Uint16Array(10);let n=t[1]>>>13;t[1]&=8191;for(let e=2;e<10;e++)t[e]+=n,n=t[e]>>>13,t[e]&=8191;t[0]+=5*n,n=t[0]>>>13,t[0]&=8191,t[1]+=n,n=t[1]>>>13,t[1]&=8191,t[2]+=n,r[0]=t[0]+5,n=r[0]>>>13,r[0]&=8191;for(let e=1;e<10;e++)r[e]=t[e]+n,n=r[e]>>>13,r[e]&=8191;r[9]-=8192;let o=(1^n)-1;for(let t=0;t<10;t++)r[t]&=o;o=~o;for(let e=0;e<10;e++)t[e]=t[e]&o|r[e];t[0]=65535&(t[0]|t[1]<<13),t[1]=65535&(t[1]>>>3|t[2]<<10),t[2]=65535&(t[2]>>>6|t[3]<<7),t[3]=65535&(t[3]>>>9|t[4]<<4),t[4]=65535&(t[4]>>>12|t[5]<<1|t[6]<<14),t[5]=65535&(t[6]>>>2|t[7]<<11),t[6]=65535&(t[7]>>>5|t[8]<<8),t[7]=65535&(t[8]>>>8|t[9]<<5);let i=t[0]+e[0];t[0]=65535&i;for(let r=1;r<8;r++)i=(t[r]+e[r]|0)+(i>>>16)|0,t[r]=65535&i}update(t){ao.exists(this);const{buffer:e,blockLen:r}=this,n=(t=ro(t)).length;for(let o=0;o<n;){const i=Math.min(r-this.pos,n-o);if(i!==r)e.set(t.subarray(o,o+i),this.pos),this.pos+=i,o+=i,this.pos===r&&(this.process(e,0,!1),this.pos=0);else for(;r<=n-o;o+=r)this.process(t,o)}return this}destroy(){this.h.fill(0),this.r.fill(0),this.buffer.fill(0),this.pad.fill(0)}digestInto(t){ao.exists(this),ao.output(t,this),this.finished=!0;const{buffer:e,h:r}=this;let{pos:n}=this;if(n){for(e[n++]=1;n<16;n++)e[n]=0;this.process(e,0,!0)}this.finalize();let o=0;for(let e=0;e<8;e++)t[o++]=r[e]>>>0,t[o++]=r[e]>>>8;return t}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}}const uo=function(t){const e=(e,r)=>t(r).update(ro(e)).digest(),r=t(new Uint8Array(32));return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=e=>t(e),e}((t=>new fo(t))),ho=eo("expand 16-byte k"),lo=eo("expand 32-byte k"),po=to(ho),yo=to(lo),go=t=>!(t.byteOffset%4),wo=t=>{const{core:e,rounds:r,counterRight:n,counterLen:o,allow128bitKeys:i,extendNonceFn:s,blockLen:a}=function(t,e){if(void 0!==e&&("object"!=typeof e||(r=e,"[object Object]"!==Object.prototype.toString.call(r)||r.constructor!==Object)))throw new Error("options must be object or undefined");var r;return Object.assign(t,e)}({rounds:20,counterRight:!1,counterLen:8,allow128bitKeys:!0,blockLen:64},t);ao.number(o),ao.number(r),ao.number(a),ao.bool(n),ao.bool(i);const c=a/4;if(a%4!=0)throw new Error("Salsa/ChaCha: blockLen must be aligned to 4 bytes");return(t,f,u,h,d=0)=>{if(ao.bytes(t),ao.bytes(f),ao.bytes(u),h||(h=new Uint8Array(u.length)),ao.bytes(h),ao.number(d),d<0||d>=2**32-1)throw new Error("Salsa/ChaCha: counter overflow");if(h.length<u.length)throw new Error(`Salsa/ChaCha: output (${h.length}) is shorter than data (${u.length})`);const l=[];let p,y;if(32===t.length)go(t)?p=t:(p=t.slice(),l.push(p)),y=yo;else{if(16!==t.length||!i)throw new Error(`Salsa/ChaCha: invalid 32-byte key, got length=${t.length}`);p=new Uint8Array(32),p.set(t),p.set(t,16),y=po,l.push(p)}if(go(f)||(f=f.slice(),l.push(f)),s){if(f.length<=16)throw new Error("Salsa/ChaCha: extended nonce must be bigger than 16 bytes");p=s(y,p,f.subarray(0,16),new Uint8Array(32)),l.push(p),f=f.subarray(16)}const g=16-o;if(f.length!==g)throw new Error(`Salsa/ChaCha: nonce must be ${g} or 16 bytes`);if(12!==g){const t=new Uint8Array(12);t.set(f,n?0:12-f.length),l.push(f=t)}const w=new Uint8Array(a),b=to(w),m=to(p),E=to(f),v=go(u)&&to(u),x=go(h)&&to(h);l.push(b);const A=u.length;for(let t=0,n=d;t<A;n++){if(e(y,m,E,b,n,r),n>=2**32-1)throw new Error("Salsa/ChaCha: counter overflow");const o=Math.min(a,A-t);if(o===a&&x&&v){const e=t/4;if(t%4!=0)throw new Error("Salsa/ChaCha: invalid block position");for(let t=0;t<c;t++)x[e+t]=v[e+t]^b[t];t+=a}else{for(let e=0;e<o;e++)h[t+e]=u[t+e]^w[e];t+=o}}for(let t=0;t<l.length;t++)l[t].fill(0);return h}},bo=(t,e)=>t<<e|t>>>32-e;const mo=wo({core:function(t,e,r,n,o,i=20){let s=t[0],a=t[1],c=t[2],f=t[3],u=e[0],h=e[1],d=e[2],l=e[3],p=e[4],y=e[5],g=e[6],w=e[7],b=o,m=r[0],E=r[1],v=r[2],x=s,A=a,B=c,S=f,I=u,P=h,U=d,k=l,$=p,L=y,O=g,R=w,T=b,N=m,C=E,D=v;for(let t=0;t<i;t+=2)x=x+I|0,T=bo(T^x,16),$=$+T|0,I=bo(I^$,12),x=x+I|0,T=bo(T^x,8),$=$+T|0,I=bo(I^$,7),A=A+P|0,N=bo(N^A,16),L=L+N|0,P=bo(P^L,12),A=A+P|0,N=bo(N^A,8),L=L+N|0,P=bo(P^L,7),B=B+U|0,C=bo(C^B,16),O=O+C|0,U=bo(U^O,12),B=B+U|0,C=bo(C^B,8),O=O+C|0,U=bo(U^O,7),S=S+k|0,D=bo(D^S,16),R=R+D|0,k=bo(k^R,12),S=S+k|0,D=bo(D^S,8),R=R+D|0,k=bo(k^R,7),x=x+P|0,D=bo(D^x,16),O=O+D|0,P=bo(P^O,12),x=x+P|0,D=bo(D^x,8),O=O+D|0,P=bo(P^O,7),A=A+U|0,T=bo(T^A,16),R=R+T|0,U=bo(U^R,12),A=A+U|0,T=bo(T^A,8),R=R+T|0,U=bo(U^R,7),B=B+k|0,N=bo(N^B,16),$=$+N|0,k=bo(k^$,12),B=B+k|0,N=bo(N^B,8),$=$+N|0,k=bo(k^$,7),S=S+I|0,C=bo(C^S,16),L=L+C|0,I=bo(I^L,12),S=S+I|0,C=bo(C^S,8),L=L+C|0,I=bo(I^L,7);let K=0;n[K++]=s+x|0,n[K++]=a+A|0,n[K++]=c+B|0,n[K++]=f+S|0,n[K++]=u+I|0,n[K++]=h+P|0,n[K++]=d+U|0,n[K++]=l+k|0,n[K++]=p+$|0,n[K++]=y+L|0,n[K++]=g+O|0,n[K++]=w+R|0,n[K++]=b+T|0,n[K++]=m+N|0,n[K++]=E+C|0,n[K++]=v+D|0},counterRight:!1,counterLen:8,extendNonceFn:function(t,e,r,n){const o=to(e),i=to(r),s=to(n);let a=t[0],c=t[1],f=t[2],u=t[3],h=o[0],d=o[1],l=o[2],p=o[3],y=o[4],g=o[5],w=o[6],b=o[7],m=i[0],E=i[1],v=i[2],x=i[3];for(let t=0;t<20;t+=2)a=a+h|0,m=bo(m^a,16),y=y+m|0,h=bo(h^y,12),a=a+h|0,m=bo(m^a,8),y=y+m|0,h=bo(h^y,7),c=c+d|0,E=bo(E^c,16),g=g+E|0,d=bo(d^g,12),c=c+d|0,E=bo(E^c,8),g=g+E|0,d=bo(d^g,7),f=f+l|0,v=bo(v^f,16),w=w+v|0,l=bo(l^w,12),f=f+l|0,v=bo(v^f,8),w=w+v|0,l=bo(l^w,7),u=u+p|0,x=bo(x^u,16),b=b+x|0,p=bo(p^b,12),u=u+p|0,x=bo(x^u,8),b=b+x|0,p=bo(p^b,7),a=a+d|0,x=bo(x^a,16),w=w+x|0,d=bo(d^w,12),a=a+d|0,x=bo(x^a,8),w=w+x|0,d=bo(d^w,7),c=c+l|0,m=bo(m^c,16),b=b+m|0,l=bo(l^b,12),c=c+l|0,m=bo(m^c,8),b=b+m|0,l=bo(l^b,7),f=f+p|0,E=bo(E^f,16),y=y+E|0,p=bo(p^y,12),f=f+p|0,E=bo(E^f,8),y=y+E|0,p=bo(p^y,7),u=u+h|0,v=bo(v^u,16),g=g+v|0,h=bo(h^g,12),u=u+h|0,v=bo(v^u,8),g=g+v|0,h=bo(h^g,7);return s[0]=a,s[1]=c,s[2]=f,s[3]=u,s[4]=m,s[5]=E,s[6]=v,s[7]=x,n},allow128bitKeys:!1}),Eo=new Uint8Array(16),vo=(t,e)=>{t.update(e);const r=e.length%16;r&&t.update(Eo.subarray(r))},xo=(t,e,r,n,o)=>{const i=t(e,r,new Uint8Array(32)),s=uo.create(i);o&&vo(s,o),vo(s,n);const a=new Uint8Array(16),c=(f=a,new DataView(f.buffer,f.byteOffset,f.byteLength));var f;oo(c,0,BigInt(o?o.length:0),!0),oo(c,8,BigInt(n.length),!0),s.update(a);const u=s.digest();return i.fill(0),u},Ao=t=>(e,r,n)=>(no(e,32),no(r),{tagLength:16,encrypt:(o,i)=>{const s=o.length,a=s+16;i?no(i,a):i=new Uint8Array(a),t(e,r,o,i,1);const c=xo(t,e,r,i.subarray(0,-16),n);return i.set(c,s),i},decrypt:(o,i)=>{const s=o.length,a=s-16;if(s<16)throw new Error("encrypted data must be at least 16 bytes");i?no(i,a):i=new Uint8Array(a);const c=o.subarray(0,-16);if(!function(t,e){if(t.length!==e.length)throw new Error("equalBytes: Different size of Uint8Arrays");let r=!0;for(let n=0;n<t.length;n++)r&&(r=t[n]===e[n]);return r}(o.subarray(-16),xo(t,e,r,c,n)))throw new Error("invalid tag");return t(e,r,c,i,1),i}}),Bo=Ao(mo),So={toString:qt,fromString:Jt,concat:m};function Io(t){return So.toString(t,"base64url")}function Po(t){const e=t.replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"");return So.fromString(e,"base64url")}function Uo(t){return So.fromString(t,"base58btc")}function ko(t,e){let r=t.startsWith("0x")?t.substring(2):t;if(r.length%2!=0&&(r=`0${r}`),e){const t=Math.max(r.length,2*e);r=r.padStart(t,"00")}return So.fromString(r.toLowerCase(),"base16")}function $o(t){return Io(So.fromString(t))}function Lo(t){return So.toString(Po(t))}function Oo(t){return So.toString(t,"base16")}function Ro(t){return BigInt("0x"+So.toString(t,"base16"))}function To(t){return So.fromString(t)}function No({r:t,s:e,recoveryParam:r},n){const o=new Uint8Array(n?65:64);if(o.set(So.fromString(t,"base16"),0),o.set(So.fromString(e,"base16"),32),n){if(void 0===r)throw new Error("Signer did not return a recoveryParam");o[64]=r}return Io(o)}function Co(t){const e=Po(t);if(e.length<64||e.length>65)throw new TypeError(`Wrong size for signature. Expected 64 or 65 bytes, but got ${e.length}`);return{r:Oo(e.slice(0,32)),s:Oo(e.slice(32,64)),recoveryParam:65===e.length?e[64]:void 0}}function Do(t,e){return So.concat([Po(t),e?Po(e):new Uint8Array(0)])}function Ko(t,e=64){return t.length===e?t:"0".repeat(e-t.length)+t}function _o(){const t=Pr.utils.randomPrivateKey();return{secretKey:t,publicKey:Pr.getPublicKey(t)}}function jo(t){if(32!==t.length)throw new Error("x25519: seed must be 32 bytes");return{publicKey:Pr.getPublicKey(t),secretKey:t}}function Ho(){const t=_o();return{publicKeyJWK:{kty:"OKP",crv:"X25519",x:Io(t.publicKey)},secretKey:t.secretKey}}function Wo(t){const e="string"==typeof t?Jt(t):t;return Tr(e)}const Jo=un;function qo(t){const e=Jt(t.slice(2),"base16");return`0x${qt(Jo(e).slice(-20),"base16")}`}function Vo(t,e=new Uint8Array(4)){const r=Jt(t.toString(),"base10");return e.set(r,4-r.length),e}const zo=t=>m([Vo(t.length),t]);function Fo(t,e,r,n,o){if(256!==e)throw new Error(`Unsupported key length: ${e}`);const i=m([zo(Jt(r)),zo(void 0===n?new Uint8Array(0):n),zo(void 0===o?new Uint8Array(0):o),Vo(e)]);return Wo(m([Vo(1),t,i]))}function Mo(t,e=!1){const r=t;if(32!==r.length)throw new Error(`bad_key: Invalid private key format. Expecting 32 bytes, but got ${r.length}`);return function(t){try{const n=Un.sign(Wo(t),r);return Promise.resolve(No({r:Ko(n.r.toString(16)),s:Ko(n.s.toString(16)),recoveryParam:n.recovery},e))}catch(t){return Promise.reject(t)}}}function Go(t){const e=Mo(ko(t),!0);return function(t){try{return Promise.resolve(e(t)).then(Co)}catch(t){return Promise.reject(t)}}}function Zo(t){return Mo(ko(t))}function Xo(t){const e=t;if(64!==e.length)throw new Error(`bad_key: Invalid private key format. Expecting 64 bytes, but got ${e.length}`);return function(t){try{const r="string"==typeof t?To(t):t,n=Ir.sign(r,e.slice(0,32));return Promise.resolve(Io(n))}catch(t){return Promise.reject(t)}}}function Yo(t){return Xo(Po(t))}function Qo(t){if(32!==t.length)throw new Error(`bad_key: Invalid private key format. Expecting 32 bytes, but got ${t.length}`);return function(e){try{const r=$n.sign(Wo(e),t);return Promise.resolve(No({r:Ko(r.r.toString(16)),s:Ko(r.s.toString(16))}))}catch(t){return Promise.reject(t)}}}function ti(t){return"object"==typeof t&&"r"in t&&"s"in t}function ei(t){return function(e,r){try{return Promise.resolve(r(e)).then((function(e){if(ti(e))return No(e,t);if(t&&void 0===Co(e).recoveryParam)throw new Error("not_supported: ES256K-R not supported when signer doesn't provide a recovery param");return e}))}catch(t){return Promise.reject(t)}}}function ri(){return function(t,e){try{return Promise.resolve(e(t)).then((function(t){if(ti(t))throw new Error("invalid_config: expected a signer function that returns a string instead of signature object");return t}))}catch(t){return Promise.reject(t)}}}const ni={ES256:function(t,e){try{return Promise.resolve(e(t)).then((function(t){return ti(t)?No(t):t}))}catch(t){return Promise.reject(t)}},ES256K:ei(),"ES256K-R":ei(!0),Ed25519:ri(),EdDSA:ri()};function oi(t,e){if(e){const r=e.split(":");switch(r[0]){case"bip122":r[r.length-1]=function(t,e){const r=Oo(Uo(e).slice(0,1)),n=ko(t),o=r+Oo(Mr(Wo(n))),i=Wo(ko(o));return s=ko(o+Oo(Wo(i)).substring(0,8)),So.toString(s,"base58btc");var s}(t,r[r.length-1]);break;case"cosmos":r[r.length-1]=function(t,e){const r=Un.ProjectivePoint.fromHex(t).toRawBytes(),n=Mr(Wo(r)),o=Yn.toWords(n);return Yn.encode(e,o).replace(e,"")}(t,r[1]);break;case"eip155":r[r.length-1]=qo(t);break;default:return!1}return r.join(":").toLowerCase()===e.toLowerCase()}return!1}function ii(t,e=!1){const r=Po(t);if(r.length!==(e?65:64))throw new Error("wrong signature length");return{compact:r.slice(0,64),recovery:r[64]}}function si(t){if(t.publicKeyBase58)return Uo(t.publicKeyBase58);if(t.publicKeyBase64)return Po(t.publicKeyBase64);if(t.publicKeyHex)return ko(t.publicKeyHex);if(t.publicKeyJwk&&"secp256k1"===t.publicKeyJwk.crv&&t.publicKeyJwk.x&&t.publicKeyJwk.y)return Un.ProjectivePoint.fromAffine({x:Ro(Po(t.publicKeyJwk.x)),y:Ro(Po(t.publicKeyJwk.y))}).toRawBytes(!1);if(t.publicKeyJwk&&"P-256"===t.publicKeyJwk.crv&&t.publicKeyJwk.x&&t.publicKeyJwk.y)return $n.ProjectivePoint.fromAffine({x:Ro(Po(t.publicKeyJwk.x)),y:Ro(Po(t.publicKeyJwk.y))}).toRawBytes(!1);if(t.publicKeyJwk&&"OKP"===t.publicKeyJwk.kty&&["Ed25519","X25519"].includes(t.publicKeyJwk.crv??"")&&t.publicKeyJwk.x)return Po(t.publicKeyJwk.x);if(t.publicKeyMultibase){const{base16:e,base58btc:r,base64:n,base64url:o}=Kt;return e.decoder.or(r.decoder.or(n.decoder.or(o.decoder))).decode(t.publicKeyMultibase)}return new Uint8Array}function ai(t,e,r){const n=[];if(e.length>86)n.push(ii(e,!0));else{const t=ii(e,!1);n.push({...t,recovery:0}),n.push({...t,recovery:1})}const o=Wo(t),i=t=>{const e=Un.Signature.fromCompact(t.compact).addRecoveryBit(t.recovery||0).recoverPublicKey(o),n=qo(e.toHex(!1)).toLowerCase(),i=e.toHex(!1),s=e.toHex(!0);return r.find((t=>{const e=Oo(si(t));return e===i||e===s||t.ethereumAddress?.toLowerCase()===n||t.blockchainAccountId?.split("@eip155")?.[0].toLowerCase()===n||oi(i,t.blockchainAccountId)}))};for(const t of n){const e=i(t);if(e)return e}throw new Error("invalid_signature: Signature invalid for JWT")}function ci(t,e,r){const n=To(t),o=Po(e),i=r.find((t=>Ir.verify(o,n,si(t))));if(!i)throw new Error("invalid_signature: Signature invalid for JWT");return i}const fi={ES256:function(t,e,r){const n=Wo(t),o=$n.Signature.fromCompact(ii(e).compact),i=r.filter((t=>!t.ethereumAddress&&!t.blockchainAccountId)).find((t=>{try{const e=si(t);return $n.verify(o,n,e)}catch(t){return!1}}));if(!i)throw new Error("invalid_signature: Signature invalid for JWT");return i},ES256K:function(t,e,r){const n=Wo(t),o=Un.Signature.fromCompact(Po(e)).normalizeS(),i=r.filter((t=>!t.ethereumAddress&&!t.blockchainAccountId)),s=r.filter((t=>t.ethereumAddress||t.blockchainAccountId));let a=i.find((t=>{try{const e=si(t);return Un.verify(o,n,e)}catch(t){return!1}}));if(!a&&s.length>0&&(a=ai(t,e,s)),!a)throw new Error("invalid_signature: Signature invalid for JWT");return a},"ES256K-R":ai,Ed25519:ci,EdDSA:ci};function ui(t){const e=fi[t];if(!e)throw new Error(`not_supported: Unsupported algorithm ${t}`);return e}ui.toSignatureObject=function(t,e=!1){const r=Po(t);if(r.length!==(e?65:64))throw new Error("wrong signature length");const n={r:Oo(r.slice(0,32)),s:Oo(r.slice(32,64))};return e&&(n.recoveryParam=r[64]),n};const hi={INVALID_JWT:"invalid_jwt",INVALID_AUDIENCE:"invalid_config",INVALID_SIGNATURE:"invalid_signature",NO_SUITABLE_KEYS:"no_suitable_keys",NOT_SUPPORTED:"not_supported",RESOLVER_ERROR:"resolver_error"};function di(t,e){try{var r=t()}catch(t){return e(t)}return r&&r.then?r.then(void 0,e):r}const li="undefined"!=typeof Symbol?Symbol.iterator||(Symbol.iterator=Symbol("Symbol.iterator")):"@@iterator";function pi(t,e,r){if(!t.s){if(r instanceof yi){if(!r.s)return void(r.o=pi.bind(null,t,e));1&e&&(e=r.s),r=r.v}if(r&&r.then)return void r.then(pi.bind(null,t,e),pi.bind(null,t,2));t.s=e,t.v=r;const n=t.o;n&&n(t)}}const yi=function(){function t(){}return t.prototype.then=function(e,r){const n=new t,o=this.s;if(o){const t=1&o?e:r;if(t){try{pi(n,1,t(this.v))}catch(t){pi(n,2,t)}return n}return this}return this.o=function(t){try{const o=t.v;1&t.s?pi(n,1,e?e(o):o):r?pi(n,1,r(o)):pi(n,2,o)}catch(t){pi(n,2,t)}},n},t}();function gi(t){return t instanceof yi&&1&t.s}const wi=function(t,{header:e,payload:r,signature:n,data:o},i,s){try{if(i.conditionWeightedThreshold)return function(t,{header:e,payload:r,data:n,signature:o},i,s){try{let c;function a(t){if(c)return t;throw new Error(`${hi.INVALID_SIGNATURE}: condition for authenticator ${i.id} is not met.`)}if(!i.conditionWeightedThreshold||!i.threshold)throw new Error("Expected conditionWeightedThreshold and threshold");const f=[],u=i.threshold;let h=0;const d=function(t,e,r){if("function"==typeof t[li]){var n,o,i,s=t[li]();if(function t(a){try{for(;!((n=s.next()).done||r&&r());)if((a=e(n.value))&&a.then){if(!gi(a))return void a.then(t,i||(i=pi.bind(null,o=new yi,2)));a=a.v}o?pi(o,1,a):o=a}catch(t){pi(o||(o=new yi),2,t)}}(),s.return){var a=function(t){try{n.done||s.return()}catch(t){}return t};if(o&&o.then)return o.then(a,(function(t){throw a(t)}));a()}return o}if(!("length"in t))throw new TypeError("Object is not iterable");for(var c=[],f=0;f<t.length;f++)c.push(t[f]);return function(t,e,r){var n,o,i=-1;return function s(a){try{for(;++i<t.length&&(!r||!r());)if((a=e(i))&&a.then){if(!gi(a))return void a.then(s,o||(o=pi.bind(null,n=new yi,2)));a=a.v}n?pi(n,1,a):n=a}catch(t){pi(n||(n=new yi),2,t)}}(),n}(c,(function(t){return e(c[t])}),r)}(i.conditionWeightedThreshold,(function(a){function d(t){return c?t:p&&!f.includes(p.id)&&(f.push(p.id),h+=a.weight,h>=u)?(c=1,i):void 0}const l=a.condition;let p;const y=di((function(){if(l.type===mi){if(!s.didAuthenticator)throw new Error("Expected didAuthenticator");const e={...s,didAuthenticator:{didResolutionResult:s.didAuthenticator?.didResolutionResult,authenticators:[l],issuer:l.id}};return Promise.resolve(Bi(t,e)).then((function({verified:t}){t&&(p=l)}))}return Promise.resolve(Ki({header:e,payload:r,data:n,signature:o},l)).then((function(t){p=t}))}),(function(t){if(!t.message.startsWith(hi.INVALID_SIGNATURE))throw t}));return y&&y.then?y.then(d):d(y)}),(function(){return c}));return Promise.resolve(d&&d.then?d.then(a):a(d))}catch(l){return Promise.reject(l)}}(t,{header:e,payload:r,data:o,signature:n},i,s);if(i.conditionDelegated)return function(t,{header:e,payload:r,data:n,signature:o},i,s){try{if(!i.conditionDelegated)throw new Error("Expected conditionDelegated");if(!s.resolver)throw new Error("Expected resolver");let a;const c=i.conditionDelegated;return Promise.resolve(Ai(s.resolver,e.alg,c,s.proofPurpose)).then((function(f){function u(t){if(a)return i;throw new Error(`${hi.INVALID_SIGNATURE}: condition for authenticator ${i.id} is not met.`)}const h=f.didResolutionResult;if(!h?.didDocument)throw new Error(`${hi.RESOLVER_ERROR}: Could not resolve delegated DID ${c}.`);const d=f.authenticators.find((t=>t.id===c));if(!d)throw new Error(`${hi.NO_SUITABLE_KEYS}: Could not find delegated authenticator ${c} in it's DID Document`);const l=d.type===mi?Promise.resolve(Bi(t,{...s,didAuthenticator:{didResolutionResult:h,authenticators:[d],issuer:d.id}})).then((function({verified:t}){t&&(a=d)})):di((function(){return Promise.resolve(Ki({header:e,payload:r,data:n,signature:o},d)).then((function(t){a=t}))}),(function(t){if(!t.message.startsWith("invalid_signature:"))throw t}));return l&&l.then?l.then(u):u()}))}catch(t){return Promise.reject(t)}}(t,{header:e,payload:r,data:o,signature:n},i,s);throw new Error(`${hi.INVALID_JWT}: conditional proof type did not find condition for authenticator ${i.id}.`)}catch(t){return Promise.reject(t)}},bi=function(t,{header:e,payload:r,signature:n,data:o},i,s){try{return i.type===mi?wi(t,{payload:r,header:e,signature:n,data:o},i,s):Promise.resolve(Ki({header:e,payload:r,data:o,signature:n},[i]))}catch(t){return Promise.reject(t)}},mi="ConditionalProof2022";function Ei(t,e,r){if(!t.s){if(r instanceof vi){if(!r.s)return void(r.o=Ei.bind(null,t,e));1&e&&(e=r.s),r=r.v}if(r&&r.then)return void r.then(Ei.bind(null,t,e),Ei.bind(null,t,2));t.s=e,t.v=r;const n=t.o;n&&n(t)}}const vi=function(){function t(){}return t.prototype.then=function(e,r){const n=new t,o=this.s;if(o){const t=1&o?e:r;if(t){try{Ei(n,1,t(this.v))}catch(t){Ei(n,2,t)}return n}return this}return this.o=function(t){try{const o=t.v;1&t.s?Ei(n,1,e?e(o):o):r?Ei(n,1,r(o)):Ei(n,2,o)}catch(t){Ei(n,2,t)}},n},t}();function xi(t){return t instanceof vi&&1&t.s}const Ai=function(t,e,r,n){try{const o=Ui[e];if(!o||0===o.length)throw new Error(`${hi.NOT_SUPPORTED}: No supported signature types for algorithm ${e}`);let i;return Promise.resolve(t.resolve(r,{accept:Ri})).then((function(t){if(i=-1===Object.getOwnPropertyNames(t).indexOf("didDocument")?{didDocument:t,didDocumentMetadata:{},didResolutionMetadata:{contentType:Ri}}:t,i.didResolutionMetadata?.error||null==i.didDocument){const{error:t,message:e}=i.didResolutionMetadata;throw new Error(`${hi.RESOLVER_ERROR}: Unable to resolve DID document for ${r}: ${t}, ${e||""}`)}const s=(t,e)=>{const r=t.filter((({id:t})=>e===t));return r.length>0?r[0]:null};let a=[...i?.didDocument?.verificationMethod||[],...i?.didDocument?.publicKey||[]];"string"==typeof n&&(n.startsWith("assertion")&&!Object.getOwnPropertyNames(i?.didDocument).includes("assertionMethod")&&(i.didDocument={...i.didDocument},i.didDocument.assertionMethod=[...a.map((t=>t.id))]),a=(i.didDocument[n]||[]).map((t=>"string"==typeof t?s(a,t):"string"==typeof t.publicKey?s(a,t.publicKey):t)).filter((t=>null!=t)));const c=a.filter((({type:t})=>o.find((e=>e===t))));if("string"==typeof n&&(!c||0===c.length))throw new Error(`${hi.NO_SUITABLE_KEYS}: DID document for ${r} does not have public keys suitable for ${e} with ${n} purpose`);if(!c||0===c.length)throw new Error(`${hi.NO_SUITABLE_KEYS}: DID document for ${r} does not have public keys for ${e}`);return{authenticators:c,issuer:r,didResolutionResult:i}}))}catch(t){return Promise.reject(t)}},Bi=function(t,e={resolver:void 0,auth:void 0,audience:void 0,callbackUrl:void 0,skewTime:void 0,proofPurpose:void 0,policies:{},didAuthenticator:void 0}){try{function r(){function r(r){if(d){const r="number"==typeof e.policies?.now?e.policies.now:Math.floor(Date.now()/1e3),o=void 0!==e.skewTime&&e.skewTime>=0?e.skewTime:Ni,i=r+o;if(!1!==e.policies?.nbf&&n.nbf){if(n.nbf>i)throw new Error(`${hi.INVALID_JWT}: JWT not valid before nbf: ${n.nbf}`)}else if(!1!==e.policies?.iat&&n.iat&&n.iat>i)throw new Error(`${hi.INVALID_JWT}: JWT not valid yet (issued in the future) iat: ${n.iat}`);if(!1!==e.policies?.exp&&n.exp&&n.exp<=r-o)throw new Error(`${hi.INVALID_JWT}: JWT has expired: exp: ${n.exp} < now: ${r}`);if(!1!==e.policies?.aud&&n.aud){if(!e.audience&&!e.callbackUrl)throw new Error(`${hi.INVALID_AUDIENCE}: JWT audience is required but your app address has not been configured`);if(void 0===(Array.isArray(n.aud)?n.aud:[n.aud]).find((t=>e.audience===t||e.callbackUrl===t)))throw new Error(`${hi.INVALID_AUDIENCE}: JWT audience does not match your DID or callback url`)}return{verified:!0,payload:n,didResolutionResult:h,issuer:u,signer:d,jwt:t,policies:e.policies}}throw new Error(`${hi.INVALID_SIGNATURE}: JWT not valid. issuer DID document does not contain a verificationMethod that matches the signature.`)}const{did:a}=function(t){if(""===t||!t)return null;const e=t.match(Tn);if(e){const r={did:`did:${e[1]}:${e[2]}`,method:e[1],id:e[2],didUrl:t};if(e[4]){const t=e[4].slice(1).split(";");r.params={};for(const e of t){const t=e.split("=");r.params[t[0]]=t[1]}}return e[6]&&(r.path=e[6]),e[7]&&(r.query=e[7].slice(1)),e[8]&&(r.fragment=e[8].slice(1)),r}return null}(c);let d=null;const l=function(){if(a!==c){const r=f.find((t=>t.id===c));if(!r)throw new Error(`${hi.INVALID_JWT}: No authenticator found for did URL ${c}`);return Promise.resolve(bi(t,{payload:n,header:o,signature:i,data:s},r,e)).then((function(t){d=t}))}{let r=0;return function(t,e,r){for(var n;;){var o=t();if(xi(o)&&(o=o.v),!o)return i;if(o.then){n=0;break}var i=r();if(i&&i.then){if(!xi(i)){n=1;break}i=i.s}if(e){var s=e();if(s&&s.then&&!xi(s)){n=2;break}}}var a=new vi,c=Ei.bind(null,a,2);return(0===n?o.then(u):1===n?i.then(f):s.then(h)).then(void 0,c),a;function f(n){i=n;do{if(e&&(s=e())&&s.then&&!xi(s))return void s.then(h).then(void 0,c);if(!(o=t())||xi(o)&&!o.v)return void Ei(a,1,i);if(o.then)return void o.then(u).then(void 0,c);xi(i=r())&&(i=i.v)}while(!i||!i.then);i.then(f).then(void 0,c)}function u(t){t?(i=r())&&i.then?i.then(f).then(void 0,c):f(i):Ei(a,1,i)}function h(){(o=t())?o.then?o.then(u).then(void 0,c):u(o):Ei(a,1,i)}}((function(){return!d&&r<f.length}),void 0,(function(){function a(t){r++}const c=f[r],u=function(r,a){try{var f=Promise.resolve(bi(t,{payload:n,header:o,signature:i,data:s},c,e)).then((function(t){d=t}))}catch(t){return a(t)}return f&&f.then?f.then(void 0,a):f}(0,(function(t){if(!t.message.includes(hi.INVALID_SIGNATURE)||r===f.length-1)throw t}));return u&&u.then?u.then(a):a()}))}}();return l&&l.then?l.then(r):r()}if(!e.resolver)throw new Error("missing_resolver: No DID resolver has been configured");const{payload:n,header:o,signature:i,data:s}=Di(t,!1),a=Object.prototype.hasOwnProperty.call(e,"auth")?e.auth?"authentication":void 0:e.proofPurpose;let c,f,u,h;if(!n.iss&&!n.client_id)throw new Error(`${hi.INVALID_JWT}: JWT iss or client_id are required`);if(e.didAuthenticator)c=e.didAuthenticator.issuer;else if(n.iss===ki||n.iss===$i){if(!n.sub)throw new Error(`${hi.INVALID_JWT}: JWT sub is required`);c=void 0===n.sub_jwk?n.sub:(o.kid||"").split("#")[0]}else if(n.iss===Li){if(!n.did)throw new Error(`${hi.INVALID_JWT}: JWT did is required`);c=n.did}else if(!n.iss&&"openid"===n.scope&&n.redirect_uri){if(!n.client_id)throw new Error(`${hi.INVALID_JWT}: JWT client_id is required`);c=n.client_id}else c=n.iss;if(!c)throw new Error(`${hi.INVALID_JWT}: No DID has been found in the JWT`);const d=function(){if(!e.didAuthenticator)return Promise.resolve(Ai(e.resolver,o.alg,c,a)).then((function(t){({didResolutionResult:h,authenticators:f,issuer:u}=t),e.didAuthenticator={didResolutionResult:h,authenticators:f,issuer:u}}));({didResolutionResult:h,authenticators:f,issuer:u}=e.didAuthenticator)}();return Promise.resolve(d&&d.then?d.then(r):r())}catch(l){return Promise.reject(l)}},Si=function(t,{expiresIn:e,canonicalize:r},n){try{if(0===n.length)throw new Error("invalid_argument: must provide one or more issuers");let f=t,u="";const h=(o=n,i=function(t){const o=n[t],i={typ:"JWT",alg:o.alg};return 0!==t&&(i.cty="JWT"),Promise.resolve(Ii(f,{...o,canonicalize:r,expiresIn:e},i)).then((function(t){u=t,f={jwt:u}}))},c=-1,function t(e){try{for(;++c<o.length;)if((e=i(c))&&e.then){if(!xi(e))return void e.then(t,a||(a=Ei.bind(null,s=new vi,2)));e=e.v}s?Ei(s,1,e):s=e}catch(t){Ei(s||(s=new vi),2,t)}}(),s);return Promise.resolve(h&&h.then?h.then((function(){return u})):u)}catch(t){return Promise.reject(t)}var o,i,s,a,c},Ii=function(t,{issuer:e,signer:r,alg:n,expiresIn:o,canonicalize:i},s={}){try{if(!r)throw new Error("missing_signer: No Signer functionality has been configured");if(!e)throw new Error("missing_issuer: No issuing DID has been configured");s.typ||(s.typ="JWT"),s.alg||(s.alg=n);const a={iat:Math.floor(Date.now()/1e3),exp:void 0};if(o){if("number"!=typeof o)throw new Error("invalid_argument: JWT expiresIn is not a number");a.exp=(t.nbf||a.iat)+Math.floor(o)}const c={...a,...t,iss:e};return Pi(c,r,s,{canonicalize:i})}catch(t){return Promise.reject(t)}},Pi=function(t,e,r={},n={}){try{r.alg||(r.alg=Oi);const o="string"==typeof t?t:Ti(t,n.canonicalize),i=[Ti(r,n.canonicalize),o].join("."),s=function(t){const e=ni[t];if(!e)throw new Error(`not_supported: Unsupported algorithm ${t}`);return e}(r.alg);return Promise.resolve(s(i,e)).then((function(t){return[i,t].join(".")}))}catch(t){return Promise.reject(t)}},Ui={ES256:["JsonWebKey2020"],ES256K:["EcdsaSecp256k1VerificationKey2019","EcdsaSecp256k1RecoveryMethod2020","Secp256k1VerificationKey2018","Secp256k1SignatureVerificationKey2018","EcdsaPublicKeySecp256k1","JsonWebKey2020"],"ES256K-R":["EcdsaSecp256k1VerificationKey2019","EcdsaSecp256k1RecoveryMethod2020","Secp256k1VerificationKey2018","Secp256k1SignatureVerificationKey2018","EcdsaPublicKeySecp256k1","ConditionalProof2022","JsonWebKey2020"],Ed25519:["ED25519SignatureVerification","Ed25519VerificationKey2018","Ed25519VerificationKey2020","JsonWebKey2020"],EdDSA:["ED25519SignatureVerification","Ed25519VerificationKey2018","Ed25519VerificationKey2020","JsonWebKey2020"]},ki="https://self-issued.me/v2",$i="https://self-issued.me/v2/openid-vc",Li="https://self-issued.me",Oi="ES256K",Ri="application/did+json";function Ti(t,e=!1){return $o(e?Ln(t):JSON.stringify(t))}const Ni=300;function Ci(t){const e=t.match(/^([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);if(e)return{header:JSON.parse(Lo(e[1])),payload:e[2],signature:e[3],data:`${e[1]}.${e[2]}`};throw new Error("invalid_argument: Incorrect format JWS")}function Di(t,e=!0){if(!t)throw new Error("invalid_argument: no JWT passed into decodeJWT");try{const r=Ci(t),n=Object.assign(r,{payload:JSON.parse(Lo(r.payload))}),o=n.payload.iss;if("JWT"===n.header.cty&&e){const t=Di(n.payload.jwt);if(t.payload.iss!==o)throw new Error(`${hi.INVALID_JWT}: multiple issuers`);return t}return n}catch(t){throw new Error("invalid_argument: Incorrect format JWT")}}function Ki({header:t,payload:e,data:r,signature:n},o){Array.isArray(o)||(o=[o]);const i=e.iss;let s=!0;do{if(i!==e.iss)throw new Error(`${hi.INVALID_JWT}: multiple issuers`);try{return ui(t.alg)(r,n,o)}catch(t){if(!t.message.startsWith(hi.INVALID_SIGNATURE))throw t}"JWT"!==t.cty?s=!1:({payload:e,header:t,signature:n,data:r}=Di(e.jwt,!1))}while(s);throw new Error(`${hi.INVALID_SIGNATURE}: no matching public key found`)}function _i(t,e){return function({header:t,data:e,signature:r},n){return Array.isArray(n)||(n=[n]),ui(t.alg)(e,r,n)}(Ci(t),e)}const ji="undefined"!=typeof Symbol?Symbol.iterator||(Symbol.iterator=Symbol("Symbol.iterator")):"@@iterator";function Hi(t,e,r){if(!t.s){if(r instanceof Wi){if(!r.s)return void(r.o=Hi.bind(null,t,e));1&e&&(e=r.s),r=r.v}if(r&&r.then)return void r.then(Hi.bind(null,t,e),Hi.bind(null,t,2));t.s=e,t.v=r;const n=t.o;n&&n(t)}}const Wi=function(){function t(){}return t.prototype.then=function(e,r){const n=new t,o=this.s;if(o){const t=1&o?e:r;if(t){try{Hi(n,1,t(this.v))}catch(t){Hi(n,2,t)}return n}return this}return this.o=function(t){try{const o=t.v;1&t.s?Hi(n,1,e?e(o):o):r?Hi(n,1,r(o)):Hi(n,2,o)}catch(t){Hi(n,2,t)}},n},t}();function Ji(t){return t instanceof Wi&&1&t.s}function qi({ciphertext:t,tag:e,iv:r,protectedHeader:n,recipient:o},i){const s={protected:n,iv:Io(r??new Uint8Array(0)),ciphertext:Io(t),tag:Io(e??new Uint8Array(0))};return i&&(s.aad=Io(i)),o&&(s.recipients=[o]),s}const Vi=function(t,e){try{function r(t){if(null===s)throw new Error("failure: Failed to decrypt");return s}!function(t){if(!(t.protected&&t.iv&&t.ciphertext&&t.tag))throw new Error("bad_jwe: missing properties");t.recipients&&t.recipients.map((t=>{if(!t.header||!t.encrypted_key)throw new Error("bad_jwe: malformed recipients")}))}(t);const n=JSON.parse(Lo(t.protected));if(n.enc!==e.enc)throw new Error(`not_supported: Decrypter does not supported: '${n.enc}'`);const o=Do(t.ciphertext,t.tag),i=Jt(t.aad?`${t.protected}.${t.aad}`:t.protected,"utf-8");let s=null;const a="dir"===n.alg&&"dir"===e.alg?Promise.resolve(e.decrypt(o,Po(t.iv),i)).then((function(t){s=t})):function(){if(t.recipients&&0!==t.recipients.length){let r=0;return function(t,e,r){for(var n;;){var o=t();if(Ji(o)&&(o=o.v),!o)return i;if(o.then){n=0;break}var i=r();if(i&&i.then){if(!Ji(i)){n=1;break}i=i.s}if(e){var s=e();if(s&&s.then&&!Ji(s)){n=2;break}}}var a=new Wi,c=Hi.bind(null,a,2);return(0===n?o.then(u):1===n?i.then(f):s.then(h)).then(void 0,c),a;function f(n){i=n;do{if(e&&(s=e())&&s.then&&!Ji(s))return void s.then(h).then(void 0,c);if(!(o=t())||Ji(o)&&!o.v)return void Hi(a,1,i);if(o.then)return void o.then(u).then(void 0,c);Ji(i=r())&&(i=i.v)}while(!i||!i.then);i.then(f).then(void 0,c)}function u(t){t?(i=r())&&i.then?i.then(f).then(void 0,c):f(i):Hi(a,1,i)}function h(){(o=t())?o.then?o.then(u).then(void 0,c):u(o):Hi(a,1,i)}}((function(){return!s&&r<t.recipients.length}),(function(){return r++}),(function(){const a=t.recipients[r];Object.assign(a.header,n);const c=function(){if(a.header.alg===e.alg)return Promise.resolve(e.decrypt(o,Po(t.iv),i,a)).then((function(t){s=t}))}();if(c&&c.then)return c.then((function(){}))}))}throw new Error("bad_jwe: missing recipients")}();return Promise.resolve(a&&a.then?a.then(r):r())}catch(c){return Promise.reject(c)}},zi=function(t,e,r={},n,o=!1){try{if("dir"===e[0].alg){if(e.length>1)throw new Error('not_supported: Can only do "dir" encryption to one key.');return Promise.resolve(e[0].encrypt(t,r,n)).then((function(t){return qi(t,n)}))}{const i=e[0].enc;if(!e.reduce(((t,e)=>t&&e.enc===i),!0))throw new Error("invalid_argument: Incompatible encrypters passed");let s,a,c;if(o){c=e[0].genEpk?.();const t=e[0].alg;r={...r,alg:t,epk:c?.publicKeyJWK}}const f=function(t,e,r){if("function"==typeof t[ji]){var n,o,i,s=t[ji]();if(function t(a){try{for(;!((n=s.next()).done||r&&r());)if((a=e(n.value))&&a.then){if(!Ji(a))return void a.then(t,i||(i=Hi.bind(null,o=new Wi,2)));a=a.v}o?Hi(o,1,a):o=a}catch(t){Hi(o||(o=new Wi),2,t)}}(),s.return){var a=function(t){try{n.done||s.return()}catch(t){}return t};if(o&&o.then)return o.then(a,(function(t){throw a(t)}));a()}return o}if(!("length"in t))throw new TypeError("Object is not iterable");for(var c=[],f=0;f<t.length;f++)c.push(t[f]);return function(t,e,r){var n,o,i=-1;return function s(a){try{for(;++i<t.length&&(!r||!r());)if((a=e(i))&&a.then){if(!Ji(a))return void a.then(s,o||(o=Hi.bind(null,n=new Wi,2)));a=a.v}n?Hi(n,1,a):n=a}catch(t){Hi(n||(n=new Wi),2,t)}}(),n}(c,(function(t){return e(c[t])}),r)}(e,(function(e){const o=s?Promise.resolve(e.encryptCek?.(s,c)).then((function(t){t&&a?.recipients?.push(t)})):Promise.resolve(e.encrypt(t,r,n,c)).then((function(t){s=t.cek,a=qi(t,n)}));if(o&&o.then)return o.then((function(){}))}));return Promise.resolve(f&&f.then?f.then((function(){return a})):a)}}catch(t){return Promise.reject(t)}};function Fi(t){return(e,r)=>{const n=oe(24),o=Bo(t,n,r).encrypt(e);return{ciphertext:o.subarray(0,o.length-16),tag:o.subarray(o.length-16),iv:n}}}function Mi(t){const e=Fi(t),r="XC20P";return{alg:"dir",enc:r,encrypt:function(t,n={},o){try{const i=$o(JSON.stringify(Object.assign({alg:"dir"},n,{enc:r}))),s=Jt(o?`${i}.${Io(o)}`:i,"utf-8");return Promise.resolve({...e(t,s),protectedHeader:i})}catch(t){return Promise.reject(t)}}}}function Gi(t){return{alg:"dir",enc:"XC20P",decrypt:function(e,r,n){try{try{return Promise.resolve(Bo(t,r,n).decrypt(e))}catch(t){return Promise.resolve(null)}}catch(t){return Promise.reject(t)}}}}const Zi=function(t,e,r,n,o,i){try{const e="X25519",n=256,s=i?jo(i.secretKey):_o(),a={kty:"OKP",crv:e,x:Io(s.publicKey)},c=Fo(Pr.getSharedSecret(s.secretKey,t),n,r,void 0,Po(o??""));return Promise.resolve({epk:a,kek:c})}catch(t){return Promise.reject(t)}},Xi=function(t,e,r){try{function n(){let e,n;return t.header.apu&&(e=Po(t.header.apu)),t.header.apv&&(n=Po(t.header.apv)),Fo(c,i,r,e,n)}const o="X25519",i=256,s=t.header;if(s.epk?.crv!==o||void 0===s.epk.x)return Promise.resolve(null);const a=Po(s.epk.x);let c;const f=function(){if(!(e instanceof Uint8Array))return Promise.resolve(e(a)).then((function(t){c=t}));c=Pr.getSharedSecret(e,a)}();return Promise.resolve(f&&f.then?f.then(n):n())}catch(u){return Promise.reject(u)}},Yi=function(t,e,r,n,o,i){try{function s(){const t=new Uint8Array(h.length+d.length);t.set(h),t.set(d,h.length);let e=new Uint8Array(0),i=new Uint8Array(0);n&&(e=Po(n)),o&&(i=Po(o));const s=Fo(t,c,r,e,i);return{epk:u,kek:s}}const a="X25519",c=256,f=i?jo(i.secretKey):_o(),u={kty:"OKP",crv:a,x:Io(f.publicKey)},h=Pr.getSharedSecret(f.secretKey,t);let d;const l=function(){if(!(e instanceof Uint8Array))return Promise.resolve(e(t)).then((function(t){d=t}));d=Pr.getSharedSecret(e,t)}();return Promise.resolve(l&&l.then?l.then(s):s())}catch(p){return Promise.reject(p)}},Qi=function(t,e,r,n){try{function o(){const e=new Uint8Array(f.length+u.length);let r,o;return e.set(f),e.set(u,f.length),t.header.apu&&(r=Po(t.header.apu)),t.header.apv&&(o=Po(t.header.apv)),Fo(e,s,n,r,o)}const i="X25519",s=256,a=t.header;if(a.epk?.crv!==i||void 0===a.epk.x)return Promise.resolve(null);const c=Po(a.epk.x);let f,u;const h=function(){if(!(e instanceof Uint8Array))return Promise.resolve(e(c)).then((function(t){return f=t,Promise.resolve(e(r)).then((function(t){u=t}))}));f=Pr.getSharedSecret(e,c),u=Pr.getSharedSecret(e,r)}();return Promise.resolve(h&&h.then?h.then(o):o())}catch(d){return Promise.reject(d)}};function ts(t){if(32!==t.length)throw new Error("invalid_argument: incorrect secret key length for X25519");return function(e){try{if(32!==e.length)throw new Error("invalid_argument: incorrect publicKey key length for X25519");return Promise.resolve(Pr.getSharedSecret(t,e))}catch(t){return Promise.reject(t)}}}function es(t,e,r={},n,o,i){const s=function(i,s){try{return Promise.resolve(n.createKek(t,e,`${n.alg}+${o.alg}`,r.apu,r.apv,s)).then((function({epk:t,kek:e}){return Promise.resolve(o.from(e).wrap(i)).then((function(e){const i={encrypted_key:Io(e.ciphertext),header:{}};return e.iv&&(i.header.iv=Io(e.iv)),e.tag&&(i.header.tag=Io(e.tag)),r.kid&&(i.header.kid=r.kid),r.apu&&(i.header.apu=r.apu),r.apv&&(i.header.apv=r.apv),s||(i.header.alg=`${n.alg}+${o.alg}`,i.header.epk=t),i}))}))}catch(t){return Promise.reject(t)}};return{alg:o.alg,enc:i.enc,encrypt:function(t,e={},r,a){try{Object.assign(e,{alg:void 0});const c=oe(32);return Promise.resolve(s(c,a)).then((function(s){return a&&(e.alg=`${n.alg}+${o.alg}`,e.epk=a.publicKeyJWK),Promise.resolve(i.from(c).encrypt(t,e,r)).then((function(t){return{...t,recipient:s,cek:c}}))}))}catch(t){return Promise.reject(t)}},encryptCek:s,genEpk:Ho}}const rs=function(t,e){try{const r=function(t,n=[]){try{return Promise.resolve(e.resolve(t)).then((function({didResolutionMetadata:e,didDocument:o}){function i(){const e=o.keyAgreement?.map((t=>"string"==typeof t?[...o.publicKey||[],...o.verificationMethod||[]].find((e=>e.id===t)):t))?.filter((t=>void 0!==t)),r=e?.filter((t=>"X25519KeyAgreementKey2019"===t.type||"X25519KeyAgreementKey2020"===t.type))||[];if(!r.length&&!s.length)throw new Error(`no_suitable_keys: Could not find x25519 key for ${t}`);return r.map((t=>fs(si(t),t.id))).concat(...s)}if(n.push(t),e?.error||null==o)throw new Error(`resolver_error: Could not resolve ${t}: ${e.error}, ${e.message}`);let s=[];if(!o.controller&&!o.keyAgreement)throw new Error(`no_suitable_keys: Could not find x25519 key for ${t}`);const a=function(){if(o.controller){let t=Array.isArray(o.controller)?o.controller:[o.controller];t=t.filter((t=>!n.includes(t)));const e=t.map((t=>r(t,n).catch((()=>[]))));return Promise.resolve(Promise.all(e)).then((function(t){s=[].concat(...t)}))}}();return a&&a.then?a.then(i):i()}))}catch(t){return Promise.reject(t)}},n=t.map((t=>r(t)));return Promise.resolve(Promise.all(n)).then((function(t){return[].concat(...t)}))}catch(t){return Promise.reject(t)}};function ns(t,e,r={}){return hs(t,e,r)}function os(t,e={}){return us(t,e)}function is(t,e){return ps(t,e)}function ss(t){return ls(t)}function as(t){if(!(t&&t.epk&&t.iv&&t.tag))throw new Error("bad_jwe: malformed header");return t}const cs={from:t=>({wrap:function(e){try{return Promise.resolve(Fi(t)(e))}catch(t){return Promise.reject(t)}}}),alg:"XC20PKW"};function fs(t,e,r){return us(t,{kid:e,apv:r})}function us(t,e={}){return es(t,void 0,e,{createKek:Zi,alg:"ECDH-ES"},cs,{from:t=>Mi(t),enc:"XC20P"})}function hs(t,e,r={}){return es(t,e,r,{createKek:Yi,alg:"ECDH-1PU"},cs,{from:t=>Mi(t),enc:"XC20P"})}function ds(t){return ls(t)}function ls(t){const e="ECDH-ES+XC20PKW";return{alg:e,enc:"XC20P",decrypt:function(r,n,o,i){try{const s=as(i.header);return Promise.resolve(Xi(i,t,e)).then((function(t){if(!t)return null;const e=Do(i.encrypted_key,s.tag);return Promise.resolve(Gi(t).decrypt(e,Po(s.iv))).then((function(t){return null===t?null:Gi(t).decrypt(r,n,o)}))}))}catch(t){return Promise.reject(t)}}}}function ps(t,e){const r="ECDH-1PU+XC20PKW";return{alg:r,enc:"XC20P",decrypt:function(n,o,i,s){try{const a=as(s.header);return Promise.resolve(Qi(s,t,e,r)).then((function(t){if(!t)return null;const e=Do(s.encrypted_key,a.tag);return Promise.resolve(Gi(t).decrypt(e,Po(a.iv))).then((function(t){return null===t?null:Gi(t).decrypt(n,o,i)}))}))}catch(t){return Promise.reject(t)}}}}})();var o=n._D,i=n.qT,s=n.vo,a=n._J,c=n.Fh,f=n.Qu,u=n.R8,h=n.Ks,d=n.K9,l=n.kr,p=n.Gp,y=n.Qf,g=n._6,w=n.ax,b=n.P9,m=n.aD,E=n.I7,v=n.zO,x=n.pk,A=n.XX,B=n.qK,S=n.yv,I=n.xK,P=n.fq,U=n.xp,k=n.jB,$=n.bK,L=n.nr,O=n.AX,R=n.Mq,T=n.ZW,N=n.PZ,C=n.Y,D=n.Qv,K=n.$1,_=n._I,j=n.UR,H=n.C2;export{o as ES256KSigner,i as ES256Signer,s as EdDSASigner,a as EllipticSigner,c as JWT_ERROR,f as NaclSigner,u as SimpleSigner,h as base58ToBytes,d as base64ToBytes,l as computeX25519Ecdh1PUv3Kek,p as computeX25519EcdhEsKek,y as concatKDF,g as createAnonDecrypter,w as createAnonEncrypter,b as createAuthDecrypter,m as createAuthEncrypter,E as createFullEncrypter,v as createJWE,x as createJWS,A as createJWT,B as createMultisignatureJWT,S as createX25519ECDH,I as createX25519Ecdh1PUv3Kek,P as createX25519EcdhEsKek,U as decodeJWT,k as decryptJWE,$ as genX25519EphemeralKeyPair,L as hexToBytes,O as resolveX25519Encrypters,R as toEthereumAddress,T as verifyJWS,N as verifyJWT,C as x25519Decrypter,D as x25519Encrypter,K as xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2,_ as xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2,j as xc20pDirDecrypter,H as xc20pDirEncrypter};