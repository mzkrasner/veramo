"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.eddsa = exports.Eddsa = void 0;
const blake_hash_1 = __importDefault(require("blake-hash"));
const hex_1 = require("../hex");
const babyjub_1 = require("./babyjub");
const poseidon_1 = require("../poseidon");
const ff_1 = require("../ff");
class Eddsa {
    constructor() {
        this.babyJub = babyjub_1.babyJub;
    }
    static pruneBuffer(buff) {
        buff[0] = buff[0] & 0xf8;
        buff[31] = buff[31] & 0x7f;
        buff[31] = buff[31] | 0x40;
        return buff;
    }
    static prv2pub(prv) {
        // const F = babyJub.F;
        const privHex = hex_1.Hex.encodeString(prv);
        const sBuff = this.pruneBuffer((0, blake_hash_1.default)('blake512').update(privHex, 'hex').digest());
        const s = ff_1.Scalar.fromRprLE(sBuff, 0, 32);
        const A = babyjub_1.babyJub.mulPointEscalar(babyjub_1.babyJub.Base8, ff_1.Scalar.shr(s, 3));
        return A;
    }
    static signPoseidon(prv, msg) {
        const privateHex = hex_1.Hex.encodeString(prv);
        const h1 = (0, blake_hash_1.default)('blake512').update(privateHex, 'hex').digest();
        const sBuff = Eddsa.pruneBuffer(h1.slice(0, 32));
        const s = ff_1.utils.leBuff2int(sBuff);
        const A = babyjub_1.babyJub.mulPointEscalar(babyjub_1.babyJub.Base8, ff_1.Scalar.shr(s, 3));
        const msgBuff = ff_1.utils.leInt2Buff(msg, 32);
        const composeBuff = new Uint8Array(64);
        composeBuff.set(h1.slice(32, 64), 0);
        composeBuff.set(msgBuff, 32);
        const rBuff = (0, blake_hash_1.default)('blake512').update(hex_1.Hex.encodeString(composeBuff), 'hex').digest();
        let r = ff_1.utils.leBuff2int(rBuff);
        const Fr = new ff_1.F1Field(babyjub_1.babyJub.subOrder);
        r = Fr.e(r);
        const R8 = babyjub_1.babyJub.mulPointEscalar(babyjub_1.babyJub.Base8, r);
        const hm = poseidon_1.poseidon.hash([R8[0], R8[1], A[0], A[1], msg]);
        const S = Fr.add(r, Fr.mul(hm, s));
        return {
            R8: R8,
            S: S
        };
    }
    static verifyPoseidon(msg, sig, A) {
        // Check parameters
        if (typeof sig != 'object')
            return false;
        if (!Array.isArray(sig.R8))
            return false;
        if (sig.R8.length != 2)
            return false;
        if (!babyjub_1.babyJub.inCurve(sig.R8))
            return false;
        if (!Array.isArray(A))
            return false;
        if (A.length != 2)
            return false;
        if (!babyjub_1.babyJub.inCurve(A))
            return false;
        if (sig.S >= babyjub_1.babyJub.subOrder)
            return false;
        const hm = poseidon_1.poseidon.hash([sig.R8[0], sig.R8[1], A[0], A[1], msg]);
        const hms = ff_1.Scalar.e(babyjub_1.babyJub.F.toObject(hm));
        const Pleft = babyjub_1.babyJub.mulPointEscalar(babyjub_1.babyJub.Base8, sig.S);
        let Pright = babyjub_1.babyJub.mulPointEscalar(A, ff_1.Scalar.mul(hms, 8));
        Pright = babyjub_1.babyJub.addPoint(sig.R8, Pright);
        if (!babyjub_1.babyJub.F.eq(Pleft[0], Pright[0]))
            return false;
        if (!babyjub_1.babyJub.F.eq(Pleft[1], Pright[1]))
            return false;
        return true;
    }
    static packSignature(sig) {
        const buff = new Uint8Array(64);
        const R8p = babyjub_1.babyJub.packPoint(sig.R8);
        buff.set(R8p, 0);
        ff_1.Scalar.toRprLE(buff, 32, sig.S, 32);
        return buff;
    }
    static unpackSignature(sigBuff) {
        return {
            R8: babyjub_1.babyJub.unpackPoint(sigBuff.slice(0, 32)),
            S: ff_1.Scalar.fromRprLE(sigBuff, 32, 32)
        };
    }
}
exports.Eddsa = Eddsa;
exports.eddsa = Eddsa;
//# sourceMappingURL=eddsa.js.map