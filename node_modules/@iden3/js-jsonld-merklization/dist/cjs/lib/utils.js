"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertAnyToString = exports.convertStringToXsdValue = exports.validateValue = exports.byteEncoder = exports.sortArr = exports.getGraphName = void 0;
const constants_1 = require("./constants");
const types_1 = require("./types/types");
const polyfill_1 = require("@js-temporal/polyfill");
function getGraphName(q) {
    if (!q.graph.value) {
        return constants_1.MerklizationConstants.DEFAULT_GRAPH_NODE_NAME;
    }
    if (q.graph.termType !== 'BlankNode') {
        throw new Error('graph node is not of BlankNode type');
    }
    return q.graph.value;
}
exports.getGraphName = getGraphName;
const sortArr = (arr) => {
    return arr.sort((a, b) => {
        if (a < b) {
            return -1;
        }
        if (a > b) {
            return 1;
        }
        return 0;
    });
};
exports.sortArr = sortArr;
exports.byteEncoder = new TextEncoder();
const validateValue = (val) => {
    switch (typeof val) {
        case 'boolean':
        case 'string':
        case 'number':
            return;
        case 'object':
            if (val instanceof polyfill_1.Temporal.Instant) {
                return;
            }
    }
    throw new Error(`unexpected value type ${typeof val}, expected boolean | number | Temporal.Instant | string`);
};
exports.validateValue = validateValue;
const convertStringToXsdValue = (dataType, valueStr) => {
    let value;
    switch (dataType) {
        case types_1.XSDNS.Boolean:
            switch (valueStr) {
                case 'false':
                case '0':
                    value = false;
                    break;
                case 'true':
                case '1':
                    value = true;
                    break;
                default:
                    throw new Error('incorrect boolean value');
            }
            break;
        case types_1.XSDNS.Integer:
        case types_1.XSDNS.NonNegativeInteger:
        case types_1.XSDNS.NonPositiveInteger:
        case types_1.XSDNS.NegativeInteger:
        case types_1.XSDNS.PositiveInteger:
            value = parseInt(valueStr);
            if (isNaN(value) || value.toString() !== valueStr) {
                throw new Error('incorrect integer value');
            }
            break;
        case types_1.XSDNS.DateTime: {
            if (isNaN(Date.parse(valueStr))) {
                throw new Error(`error: error parsing time string ${valueStr}`);
            }
            const dateRegEx = /^\d{4}-\d{2}-\d{2}$/;
            if (dateRegEx.test(valueStr)) {
                value = polyfill_1.Temporal.Instant.from(new Date(valueStr).toISOString());
            }
            else {
                value = polyfill_1.Temporal.Instant.from(valueStr);
            }
            break;
        }
        case types_1.XSDNS.Double:
            value = (0, types_1.canonicalDouble)(parseFloat(valueStr));
            break;
        default:
            value = valueStr;
    }
    return value;
};
exports.convertStringToXsdValue = convertStringToXsdValue;
const convertAnyToString = (v, datatype) => {
    const isDoubleType = datatype === types_1.XSDNS.Double;
    switch (typeof v) {
        case 'string':
            return isDoubleType ? (0, types_1.canonicalDouble)(parseFloat(v)) : v;
        case 'boolean':
            return `${v}`;
        case 'number': {
            return isDoubleType ? (0, types_1.canonicalDouble)(v) : `${v}`;
        }
        default:
            throw new Error('unsupported type');
    }
};
exports.convertAnyToString = convertAnyToString;
//# sourceMappingURL=utils.js.map