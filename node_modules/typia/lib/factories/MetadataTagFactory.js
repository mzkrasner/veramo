"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataTagFactory = void 0;
var MetadataTagFactory;
(function (MetadataTagFactory) {
    MetadataTagFactory.generate = function (metadata) {
        return function (tagList) {
            return function (identifier) {
                var e_1, _a;
                var output = [];
                try {
                    for (var tagList_1 = __values(tagList), tagList_1_1 = tagList_1.next(); !tagList_1_1.done; tagList_1_1 = tagList_1.next()) {
                        var tag = tagList_1_1.value;
                        var elem = parse(identifier, metadata, tag, output);
                        if (elem !== null)
                            output.push(elem);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (tagList_1_1 && !tagList_1_1.done && (_a = tagList_1.return)) _a.call(tagList_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return output;
            };
        };
    };
    var parse = function (identifier, metadata, tag, output) {
        var _a;
        var closure = MetadataTagFactory._PARSER[tag.name];
        if (closure === undefined)
            return null;
        var text = (_a = (tag.text || [])[0]) === null || _a === void 0 ? void 0 : _a.text;
        if (text === undefined)
            throw new Error("".concat(LABEL, ": no tag value on ").concat(identifier()));
        return closure(identifier, metadata, text, output);
    };
    MetadataTagFactory._PARSER = {
        items: function (identifier, metadata, text, output) {
            validate(identifier, metadata, output, "items", "array", [
                "minItems",
            ]);
            return {
                kind: "items",
                value: parse_number(identifier, text),
            };
        },
        minItems: function (identifier, metadata, text, output) {
            validate(identifier, metadata, output, "minItems", "array", [
                "items",
            ]);
            return {
                kind: "minItems",
                value: parse_number(identifier, text),
            };
        },
        maxItems: function (identifier, metadata, text, output) {
            validate(identifier, metadata, output, "maxItems", "array", [
                "items",
            ]);
            return {
                kind: "maxItems",
                value: parse_number(identifier, text),
            };
        },
        type: function (_identifier, metadata, text, _output) {
            if (text.startsWith("{") && text.endsWith("}"))
                text = text.substring(1, text.length - 1);
            return has_atomic("number")(new Set())(metadata) &&
                (text === "int" ||
                    text === "uint" ||
                    text === "int32" ||
                    text === "uint32" ||
                    text === "int64" ||
                    text === "uint64" ||
                    text === "float")
                ? { kind: "type", value: text }
                : null;
        },
        minimum: function (identifier, metadata, text, output) {
            validate(identifier, metadata, output, "minimum", "number", [
                "exclusiveMinimum",
            ]);
            return {
                kind: "minimum",
                value: parse_number(identifier, text),
            };
        },
        maximum: function (identifier, metadata, text, output) {
            validate(identifier, metadata, output, "maximum", "number", [
                "exclusiveMaximum",
            ]);
            return {
                kind: "maximum",
                value: parse_number(identifier, text),
            };
        },
        exclusiveMinimum: function (identifier, metadata, text, output) {
            validate(identifier, metadata, output, "exclusiveMinimum", "number", ["minimum"]);
            return {
                kind: "exclusiveMinimum",
                value: parse_number(identifier, text),
            };
        },
        exclusiveMaximum: function (identifier, metadata, text, output) {
            validate(identifier, metadata, output, "exclusiveMaximum", "number", ["maximum"]);
            return {
                kind: "exclusiveMaximum",
                value: parse_number(identifier, text),
            };
        },
        multipleOf: function (identifier, metadata, text, output) {
            validate(identifier, metadata, output, "multipleOf", "number", [
                "step",
            ]);
            return {
                kind: "multipleOf",
                value: parse_number(identifier, text),
            };
        },
        step: function (identifier, metadata, text, output) {
            validate(identifier, metadata, output, "step", "number", [
                "multipleOf",
            ]);
            var minimum = output.some(function (tag) {
                return tag.kind === "minimum" || tag.kind === "exclusiveMinimum";
            });
            if (minimum === undefined)
                throw new Error("".concat(LABEL, ": step requires minimum or exclusiveMinimum tag on \"").concat(identifier(), "\"."));
            return {
                kind: "step",
                value: parse_number(identifier, text),
            };
        },
        format: function (identifier, metadata, str, output) {
            var value = FORMATS.get(str);
            validate(identifier, metadata, output, "format", value === "date" || value === "datetime" ? "Date" : "string", ["pattern"]);
            if (value === undefined)
                return null;
            return {
                kind: "format",
                value: value,
            };
        },
        pattern: function (identifier, metadata, value, output) {
            validate(identifier, metadata, output, "pattern", "string", [
                "format",
            ]);
            return {
                kind: "pattern",
                value: value,
            };
        },
        length: function (identifier, metadata, text, output) {
            validate(identifier, metadata, output, "length", "string", [
                "minLength",
                "maxLength",
            ]);
            return {
                kind: "length",
                value: parse_number(identifier, text),
            };
        },
        minLength: function (identifier, metadata, text, output) {
            validate(identifier, metadata, output, "minLength", "string", [
                "length",
            ]);
            return {
                kind: "minLength",
                value: parse_number(identifier, text),
            };
        },
        maxLength: function (identifier, metadata, text, output) {
            validate(identifier, metadata, output, "maxLength", "string", [
                "length",
            ]);
            return {
                kind: "maxLength",
                value: parse_number(identifier, text),
            };
        },
    };
})(MetadataTagFactory || (exports.MetadataTagFactory = MetadataTagFactory = {}));
var parse_number = function (identifier, str) {
    var value = Number(str);
    if (isNaN(value) === true)
        throw new Error("".concat(LABEL, ": invalid number on \"").concat(identifier(), "\"."));
    return value;
};
var LABEL = "Error on typia.MetadataTagFactory.generate()";
var FORMATS = new Map([
    ["uuid", "uuid"],
    ["email", "email"],
    ["url", "url"],
    ["ipv4", "ipv4"],
    ["ipv6", "ipv6"],
    ["date", "date"],
    ["datetime", "datetime"],
    ["date-time", "datetime"],
    ["dateTime", "datetime"],
]);
var WRONG_TYPE = function (tag, type, identifier) { return "".concat(LABEL, ": ").concat(tag, " requires ").concat(type, " type, but no \"").concat(identifier(), "\"."); };
var validate = function (identifier, metadata, output, kind, type, neighbors) {
    var e_2, _a;
    if (type === "array") {
        if (has_array(new Set())(metadata) === false)
            throw new Error(WRONG_TYPE(kind, "array", identifier));
    }
    else if (type === "Date") {
        if (has_native("Date")(new Set())(metadata) === false &&
            has_atomic("string")(new Set())(metadata) === false)
            throw new Error(WRONG_TYPE(kind, "string", identifier));
    }
    else if (has_atomic(type)(new Set())(metadata) === false)
        throw new Error(WRONG_TYPE(kind, type, identifier));
    if (output.some(function (tag) { return tag.kind === kind; }))
        throw new Error("".concat(LABEL, ": duplicated ").concat(kind, " tags on \"").concat(identifier(), "\"."));
    var _loop_1 = function (name_1) {
        if (output.some(function (tag) { return tag.kind === name_1; }))
            throw new Error("".concat(LABEL, ": ").concat(kind, " and ").concat(name_1, " tags on \"").concat(identifier(), "\"."));
    };
    try {
        for (var neighbors_1 = __values(neighbors), neighbors_1_1 = neighbors_1.next(); !neighbors_1_1.done; neighbors_1_1 = neighbors_1.next()) {
            var name_1 = neighbors_1_1.value;
            _loop_1(name_1);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (neighbors_1_1 && !neighbors_1_1.done && (_a = neighbors_1.return)) _a.call(neighbors_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
};
var has_atomic = function (type) {
    return function (visited) {
        return function (metadata) {
            if (visited.has(metadata))
                return false;
            visited.add(metadata);
            return (metadata.atomics.find(type === "number"
                ? function (atom) { return atom === type || atom === "bigint"; }
                : function (atom) { return atom === type; }) !== undefined ||
                metadata.arrays.some(function (array) {
                    return has_atomic(type)(visited)(array.value);
                }) ||
                metadata.tuples.some(function (tuple) {
                    return tuple.elements.some(has_atomic(type)(visited));
                }) ||
                metadata.aliases.some(function (alias) {
                    return has_atomic(type)(visited)(alias.value);
                }) ||
                (metadata.resolved !== null &&
                    has_atomic(type)(visited)(metadata.resolved.returns)));
        };
    };
};
var has_native = function (type) {
    return function (visited) {
        return function (metadata) {
            if (visited.has(metadata))
                return false;
            visited.add(metadata);
            return (metadata.natives.find(function (native) { return native === type; }) !== undefined ||
                metadata.arrays.some(function (child) {
                    return has_native(type)(visited)(child.value);
                }) ||
                metadata.tuples.some(function (tuple) {
                    return tuple.elements.some(has_native(type)(visited));
                }) ||
                metadata.aliases.some(function (alias) {
                    return has_native(type)(visited)(alias.value);
                }) ||
                (metadata.resolved !== null &&
                    has_native(type)(visited)(metadata.resolved.returns)));
        };
    };
};
var has_array = function (visited) {
    return function (metadata) {
        if (visited.has(metadata))
            return false;
        visited.add(metadata);
        return (metadata.arrays.length !== 0 ||
            metadata.tuples.some(function (tuple) {
                return tuple.elements.some(has_array(visited));
            }) ||
            metadata.aliases.some(function (alias) { return has_array(visited)(alias.value); }) ||
            (metadata.resolved !== null &&
                has_array(visited)(metadata.resolved.returns)));
    };
};
//# sourceMappingURL=MetadataTagFactory.js.map