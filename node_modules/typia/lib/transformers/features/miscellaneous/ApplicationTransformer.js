"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApplicationTransformer = void 0;
var typescript_1 = __importDefault(require("typescript"));
var LiteralFactory_1 = require("../../../factories/LiteralFactory");
var MetadataCollection_1 = require("../../../factories/MetadataCollection");
var MetadataFactory_1 = require("../../../factories/MetadataFactory");
var ApplicationProgrammer_1 = require("../../../programmers/ApplicationProgrammer");
var ApplicationTransformer;
(function (ApplicationTransformer) {
    ApplicationTransformer.transform = function (_a) {
        var checker = _a.checker;
        return function (expression) {
            var _a;
            if (!((_a = expression.typeArguments) === null || _a === void 0 ? void 0 : _a.length))
                throw new Error(NO_GENERIC_ARGUMENT);
            var top = expression.typeArguments[0];
            if (!typescript_1.default.isTupleTypeNode(top))
                return expression;
            else if (top.elements.some(function (child) { return !typescript_1.default.isTypeNode(child); }))
                return expression;
            var types = top.elements.map(function (child) {
                return checker.getTypeFromTypeNode(child);
            });
            if (types.some(function (t) { return t.isTypeParameter(); }))
                throw new Error(GENERIC_ARGUMENT);
            var purpose = get_parameter(checker, "Purpose", expression.typeArguments[1], function (str) { return str === "swagger" || str === "ajv"; }, function () { return "swagger"; });
            var collection = new MetadataCollection_1.MetadataCollection({
                replace: MetadataCollection_1.MetadataCollection.replace,
            });
            var metadatas = types.map(function (type) {
                return MetadataFactory_1.MetadataFactory.analyze(checker)({
                    resolve: true,
                    constant: true,
                    absorb: false,
                    validate: function (meta) {
                        if (meta.atomics.find(function (str) { return str === "bigint"; }))
                            throw new Error(NO_BIGIT);
                        else if (meta.arrays.some(function (array) { return array.value.isRequired() === false; }))
                            throw new Error(NO_UNDEFINED_IN_ARRAY);
                    },
                })(collection)(type);
            });
            var app = ApplicationProgrammer_1.ApplicationProgrammer.write({
                purpose: purpose,
            })(metadatas);
            return LiteralFactory_1.LiteralFactory.generate(app);
        };
    };
    var get_parameter = function (checker, name, node, predicator, defaulter) {
        if (!node)
            return defaulter();
        var type = checker.getTypeFromTypeNode(node);
        if (!type.isLiteral())
            throw new Error("Error on typia.application(): generic argument \"".concat(name, "\" must be constant."));
        var value = type.value;
        if (typeof value !== "string" || predicator(value) === false)
            throw new Error("Error on typia.application(): invalid value on generic argument \"".concat(name, "\"."));
        return value;
    };
})(ApplicationTransformer || (exports.ApplicationTransformer = ApplicationTransformer = {}));
var NO_GENERIC_ARGUMENT = "Error on typia.application(): no generic argument.";
var GENERIC_ARGUMENT = "Error on typia.application(): non-specified generic argument(s).";
var NO_BIGIT = "Error on typia.application(): does not allow bigint type.";
var NO_UNDEFINED_IN_ARRAY = "Error on typia.application(): does not allow undefined type in array.";
//# sourceMappingURL=ApplicationTransformer.js.map